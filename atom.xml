<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhanqq&#39;s Notes</title>
  
  <subtitle>天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。</subtitle>
  <link href="/QQzzZ.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhanqq2010.github.io/"/>
  <updated>2018-01-11T04:05:09.667Z</updated>
  <id>https://zhanqq2010.github.io/</id>
  
  <author>
    <name>QQzzZ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android插件化原理解析——Service插件化</title>
    <link href="https://zhanqq2010.github.io/2018/01/11/Service%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    <id>https://zhanqq2010.github.io/2018/01/11/Service插件化/</id>
    <published>2018-01-11T04:03:39.504Z</published>
    <updated>2018-01-11T04:05:09.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Service插件化"><a href="#Service插件化" class="headerlink" title="Service插件化"></a>Service插件化</h1><p>在 <a href="Activity生命周期管理.md">Activity生命周期管理</a> 以及 <a href="BroadcastReceiver插件化.md">广播的管理</a> 中我们详细探讨了Android系统中的Activity、BroadcastReceiver组件的工作原理以及它们的插件化方案，相信读者已经对Android Framework和插件化技术有了一定的了解；本文将探讨Android四大组件之一——Service组件的插件化方式。</p><p>与Activity, BroadcastReceiver相比，Service组件的不同点在哪里呢？我们能否用与之相同的方式实现Service的插件化？如果不行，它们的差别在哪里，应该如何实现Service的插件化？</p><p>我们接下来将围绕这几个问题展开，最终给出Service组件的插件化方式；阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>，参考此项目的 service-management 模块。另外，插件框架原理解析系列文章见<a href="概述.md">索引</a>。</p><a id="more"></a><h2 id="Service工作原理"><a href="#Service工作原理" class="headerlink" title="Service工作原理"></a>Service工作原理</h2><p>连Service的工作原理都不了解，谈何插件化？知己知彼。</p><p>Service分为两种形式：以startService<strong>启动</strong>的服务和用bindService<strong>绑定</strong>的服务；由于这两个过程大体相似，这里以稍复杂的<code>bindService</code>为例分析Service组件的工作原理。</p><p>绑定Service的过程是通过<code>Context</code>类的<code>bindService</code>完成的，这个方法需要三个参数：第一个参数代表想要绑定的Service的Intent，第二个参数是一个ServiceConnetion，我们可以通过这个对象接收到Service绑定成功或者失败的回调；第三个参数则是绑定时候的一些FLAG；关于服务的基本概念，可以参阅 <a href="http://developer.android.com/intl/zh-cn/guide/components/services.html" target="_blank" rel="noopener">官方文档</a>。（现在汉化了哦，E文不好童鞋的福音）</p><p>Context的具体实现在ContextImpl类，ContextImpl中的<code>bindService</code>方法直接调用了<code>bindServiceCommon</code>方法，此方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        UserHandle user)</span> </span>&#123;</span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connection is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// important</span></span><br><span class="line">        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),</span><br><span class="line">                mMainThread.getHandler(), flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not supported in system context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IBinder token = getActivityToken();</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == <span class="number">0</span> &amp;&amp; mPackageInfo != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">        &#125;</span><br><span class="line">        service.prepareToLeaveProcess();</span><br><span class="line">        <span class="keyword">int</span> res = ActivityManagerNative.getDefault().bindService(</span><br><span class="line">            mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">            sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Not allowed to bind to service "</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致观察就能发现这个方法最终通过ActivityManagerNative借助AMS进而完成Service的绑定过程，在跟踪AMS的<code>bindService</code>源码之前，我们关注一下这个方法开始处创建的<code>sd</code>变量。这个变量的类型是<code>IServiceConnection</code>，如果读者还有印象，我们在 <a href="BroadcastReceiver插件化.md">广播的管理</a> 一文中也遇到过类似的处理方式——IIntentReceiver；所以，这个IServiceConnection与IApplicationThread以及IIntentReceiver相同，都是ActivityThread给AMS提供的用来与之进行通信的Binder对象；这个接口的实现类为LoadedApk.ServiceDispatcher。</p><p>这个方法最终调用了ActivityManagerNative的bindService，而这个方法的真正实现在AMS里面，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bindService</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, IServiceConnection connection, <span class="keyword">int</span> flags, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"bindService"</span>);</span><br><span class="line">    <span class="comment">// 略去参数校检</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.bindServiceLocked(caller, token, service,</span><br><span class="line">                resolvedType, connection, flags, callingPackage, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bindService这个方法相当简单，只是做了一些参数校检之后直接调用了ActivityServices类的<code>bindServiceLocked</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, IServiceConnection connection, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">    <span class="comment">// 参数校检，略</span></span><br><span class="line"></span><br><span class="line">    ServiceLookupResult res =</span><br><span class="line">        retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class="line">                Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="keyword">true</span>, callerFg);</span><br><span class="line">    <span class="comment">// 结果校检， 略</span></span><br><span class="line">    ServiceRecord s = res.record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... 不关心， 略</span></span><br><span class="line"></span><br><span class="line">        mAm.startAssociationLocked(callerApp.uid, callerApp.processName,</span><br><span class="line">                s.appInfo.uid, s.name, s.processName);</span><br><span class="line"></span><br><span class="line">        AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line">        ConnectionRecord c = <span class="keyword">new</span> ConnectionRecord(b, activity,</span><br><span class="line">                connection, flags, clientLabel, clientIntent);</span><br><span class="line">        IBinder binder = connection.asBinder();</span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对connection进行处理， 方便存取，略</span></span><br><span class="line">        clist.add(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (bringUpServiceLocked(s, service.getFlags(), callerFg, <span class="keyword">false</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与BIND_AUTO_CREATE不同的启动FLAG，原理与后续相同，略</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法比较长，我这里省去了很多无关代码，只列出关键逻辑；首先它通过<code>retrieveServiceLocked</code>方法获取到了intent匹配到的需要bind到的Service组件<code>res</code>；然后把ActivityThread传递过来的IServiceConnection使用ConnectionRecord进行了包装，方便接下来使用；最后如果启动的FLAG为BIND_AUTO_CREATE，那么调用<code>bringUpServiceLocked</code>开始创建Service，我们跟踪这个方法：（非这种FLAG的代码已经省略，可以自行跟踪）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> whileRestarting)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略。。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> String procName = r.processName;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);</span><br><span class="line">                <span class="comment">// 1. important !!!</span></span><br><span class="line">                realStartServiceLocked(r, app, execInFg);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when starting service "</span> + r.shortName, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = r.isolatedProc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not running -- get it started, and enqueue this service record</span></span><br><span class="line">    <span class="comment">// to be executed when the app comes up.</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. important !!!</span></span><br><span class="line">        <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="keyword">true</span>, intentFlags,</span><br><span class="line">                <span class="string">"service"</span>, r.name, <span class="keyword">false</span>, isolated, <span class="keyword">false</span>)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bringDownServiceLocked(r);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">            r.isolatedProc = app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 略。。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方案同样也很长，但是实际上非常简单：注意我注释的两个important的地方，如果Service所在的进程已经启动，那么直接调用<code>realStartServiceLocked</code>方法来<strong>真正</strong>启动Service组件；如果Service所在的进程还没有启动，那么先在AMS中记下这个要启动的Service组件，然后通过<code>startProcessLocked</code>启动新的进程。</p><p>我们先看Service进程已经启动的情况，也即<code>realStartServiceLocked</code>分支：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略。。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        mAm.ensurePackageDexOpt(r.serviceInfo.packageName);</span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        mAm.appDiedLocked(app);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 略。。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不关心，略。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法首先调用了app.thread的scheduleCreateService方法，我们知道，这是一个IApplicationThread对象，它是App所在进程提供给AMS的用来与App进程进行通信的Binder对象，这个Binder的Server端在ActivityThread的ApplicationThread类，因此，我们跟踪ActivityThread类，这个方法的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        ServiceInfo info, CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    CreateServiceData s = <span class="keyword">new</span> CreateServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.info = info;</span><br><span class="line">    s.compatInfo = compatInfo;</span><br><span class="line"></span><br><span class="line">    sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它不过是转发了一个消息给ActivityThread的<code>H</code>这个Handler，<code>H</code>类收到这个消息之后，直接调用了ActivityThread类的<code>handleCreateService</code>方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span><span class="params">(CreateServiceData data)</span> </span>&#123;</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line">    Service service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line"></span><br><span class="line">        Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,</span><br><span class="line">                ActivityManagerNative.getDefault());</span><br><span class="line">        service.onCreate();</span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// nothing to do.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这段代码，是不是似曾相识？！没错，这里与Activity组件的创建过程如出一辙！所以这里就不赘述了，可以参阅 <a href="Activity生命周期管理.md">Activity生命周期管理</a>。</p><p>需要注意的是，这里Service类的创建过程与Activity是略微有点不同的，虽然都是通过ClassLoader通过反射创建，但是Activity却把创建过程委托给了Instrumentation类，而Service则是直接进行。</p><p>OK，现在ActivityThread里面的<code>handleCreateService</code>方法成功创建出了Service对象，并且调用了它的<code>onCreate</code>方法；到这里我们的Service已经启动成功。<code>scheduleCreateService</code>这个Binder调用过程结束，代码又回到了AMS进程的<code>realStartServiceLocked</code>方法。这里我们不得不感叹Binder机制的精妙，如此简洁方便高效的跨进程调用，在进程之间来回穿梭，游刃有余。</p><p><code>realStartServiceLocked</code>方法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略。。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        mAm.ensurePackageDexOpt(r.serviceInfo.packageName);</span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        mAm.appDiedLocked(app);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 略。。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不关心，略。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法在完成<code>scheduleCreateService</code>这个binder调用之后，执行了一个<code>requestServiceBindingsLocked</code>方法；看方法名好像于「绑定服务」有关，它简单地执行了一个遍历然后调用了另外一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">requestServiceBindingLocked</span><span class="params">(ServiceRecord r, IntentBindRecord i,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> rebind)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r.app == <span class="keyword">null</span> || r.app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, <span class="string">"bind"</span>);</span><br><span class="line">            r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                    r.app.repProcState);</span><br><span class="line">        <span class="comment">// 不关心，略。。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里又通过IApplicationThread这个Binder进行了一次IPC调用，我们跟踪ActivityThread类里面的ApplicationThread的<code>scheduleBindService</code>方法，发现这个方法不过通过Handler转发了一次消息，真正的处理代码在<code>handleBindService</code>里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindService</span><span class="params">(BindServiceData data)</span> </span>&#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!data.rebind) &#123;</span><br><span class="line">                    IBinder binder = s.onBind(data.intent);</span><br><span class="line">                    ActivityManagerNative.getDefault().publishService(</span><br><span class="line">                            data.token, data.intent, binder);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要Bind的Service终于在这里完成了绑定！绑定之后又通过ActivityManagerNative这个Binder进行一次IPC调用，我们查看AMS的<code>publishService</code>方法，这个方法简单第调用了<code>publishServiceLocked</code>方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishServiceLocked</span><span class="params">(ServiceRecord r, Intent intent, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Intent.FilterComparison filter</span><br><span class="line">                    = <span class="keyword">new</span> Intent.FilterComparison(intent);</span><br><span class="line">            IntentBindRecord b = r.bindings.get(filter);</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; !b.received) &#123;</span><br><span class="line">                b.binder = service;</span><br><span class="line">                b.requested = <span class="keyword">true</span>;</span><br><span class="line">                b.received = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> conni=r.connections.size()-<span class="number">1</span>; conni&gt;=<span class="number">0</span>; conni--) &#123;</span><br><span class="line">                    ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;clist.size(); i++) &#123;</span><br><span class="line">                        ConnectionRecord c = clist.get(i);</span><br><span class="line">                        <span class="keyword">if</span> (!filter.equals(c.binding.intent.intent)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            c.conn.connected(r.name, service);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得我们之前提到的那个IServiceConnection吗？在<code>bindServiceLocked</code>方法里面，我们把这个IServiceConnection放到了一个ConnectionRecord的List中存放在ServiceRecord里面，这里所做的就是取出已经被Bind的这个Service对应的IServiceConnection对象，然后调用它的<code>connected</code>方法；我们说过，这个IServiceConnection也是一个Binder对象，它的Server端在LoadedApk.ServiceDispatcher里面。代码到这里已经很明确了，由于分析过程过长，再继续估计大家要瞌睡了；接下来的过程非常简单，感兴趣的读者自行查阅LoadedApk.ServiceDispatcher的<code>connected</code>方法，一路跟踪弄清楚ServiceConnection回调过程，完成最后的拼图！</p><p>最后提一点，以上我们分析了Service所在进程已经存在的情况，如果Service所在进程不存在，那么会调用startProcessLocked方法创建一个新的进程，并把需要启动的Service放在一个队列里面；创建进程的过程通过Zygote fork出来，进程创建成功之后会调用ActivityThread的main方法，在这个main方法里面间接调用到了AMS的attachApplication方法，在AMS的attachApplication里面会检查刚刚那个待启动Service队列里面的内容，并执行Service的启动操作；之后的启动过程与进程已经存在的情况下相同；可以自行分析。</p><h2 id="Service的插件化思路"><a href="#Service的插件化思路" class="headerlink" title="Service的插件化思路"></a>Service的插件化思路</h2><p>现在我们已经明白了Service组件的工作原理，可对如何实现Service的插件化依然是一头雾水。</p><p>从上文的源码分析来看，Service组件与Activity有着非常多的相似之处：它们都是通过Context类完成启动，接着通过ActivityMnagaerNative进入AMS，最后又通过IApplicationThread这个Binder IPC到App进程的Binder线程池，然后通过H转发消息到App进程的主线程，最终完成组件生命周期的回调；对于Service组件，看起来好像可以沿用Activity组件的插件化方式：Hook掉ActivityManagerNative以及<code>H</code>类，但事实真的如此吗？</p><h3 id="Service与Activity的异同"><a href="#Service与Activity的异同" class="headerlink" title="Service与Activity的异同"></a>Service与Activity的异同</h3><p>Service组件和Activity组件有什么不同？这些不同使得我们对于插件化方案的选择又有什么影响？</p><h4 id="用户交互对于生命周期的影响"><a href="#用户交互对于生命周期的影响" class="headerlink" title="用户交互对于生命周期的影响"></a>用户交互对于生命周期的影响</h4><p>首先，Activity与Service组件最大的不同点在于，Activity组件可以与用户进行交互；这一点意味着用户的行为会对Activity组件产生影响，对我们来说最重要的影响就是Activity组件的生命周期；用户点击按钮从界面A跳转到界面B，会引起A和B这两个Activity一系列生命周期的变化。而Service组件则代表后台任务，除了内存不足系统回收之外，它的生命周期完全由我们的代码控制，与用户的交互无关。</p><p>这意味着什么？</p><p>Activity组件的生命周期受用户交互影响，而这种变化只有Android系统才能感知，因此我们必须把插件的Activity交给系统管理，才能拥有完整的生命周期；但Service组件的生命周期不受外界因素影响，那么自然而然，我们可以<strong>手动控制它的生命周期</strong>，就像我们对于BroadcastReceiver的插件化方式一样！Activity组件的插件化无疑是比较复杂的，为了把插件Activity交给系统管理进而拥有完整生命周期，我们设计了一个天衣无缝的方案骗过了AMS；既然Service的生命周期可以由我们自己控制，那么我们可以有更简单的方案实现它的插件化。</p><h4 id="Activity的任务栈"><a href="#Activity的任务栈" class="headerlink" title="Activity的任务栈"></a>Activity的任务栈</h4><p>上文指出了Activity和Service组件在处理用户交互方面的不同，这使得我们对于Service组建的插件化可以选择一种较为简单的方式；也许你会问，那采用Activity插件化的那一套技术能够实现Service组件的插件化吗？</p><p>很遗憾，答案是不行的。虽然Activity的插件化技术更复杂，但是这种方案并不能完成Service组件的插件化——复杂的方案并不意味了它能处理更多的问题。</p><p>原因在于Activity拥有任务栈的概念。或许你觉得任务栈并不是什么了不起的东西，但是，这确实是Service组件与Activity组件插件化方式分道扬镳的根本原因。</p><p>任务栈的概念使得Activtiy的创建就代表着入栈，销毁则代表出栈；又由于Activity代表着与用户交互的界面，所以这个栈的深度不可能太深——Activity栈太深意味着用户需要狂点back键才能回到初始界面，这种体验显然有问题；因此，插件框架要处理的Activity数量其实是有限的，所以我们在AndroidManifest.xml中声明有限个StubActivity就能满足插件启动近乎无限个插件Activity的需求。</p><p>但是Service组件不一样，理论情况下，可以启动的Service组件是无限的——除了硬件以及内存资源，没有什么限制它的数目；如果采用Activity的插件化方式，就算我们在AndroidMafenist.xml中声明再多的StubService，总有不能满足插件中要启动的Service数目的情况出现。也许有童鞋会说，可以用一个StubService对应多个插件Service，这确实能解决部分问题；但是，下面的这个区别让这种设想彻底泡汤。</p><h4 id="Service无法拥有多实例"><a href="#Service无法拥有多实例" class="headerlink" title="Service无法拥有多实例"></a>Service无法拥有多实例</h4><p>Service组件与Activity组件另外一个不同点在于，对同一个Service调用多次startService并不会启动多个Service实例，而非特定Flag的Activity是可以允许这种情况存在的，因此如果用StubService的方式，为了实现Service的这种特性，必须建立一个StubService到插件Service的一个Map，Map的这种一一对应关系使得我们使用一个StubService对应多个插件Service的计划成为天方夜谭。</p><p>至此，结论已经非常清晰——对于Service组件的插件化，我们不能简单地套用Activity的方案。</p><h3 id="如何实现Service的插件化？"><a href="#如何实现Service的插件化？" class="headerlink" title="如何实现Service的插件化？"></a>如何实现Service的插件化？</h3><p>上文指出，我们不能套用Activity的方案实现Service组件的插件化，可以通过手动控制Service组件的生命周期实现；我们先来看一下Service的生命周期：</p><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1462949033406.png" alt="Service生命周期"></p><p>从图中可以看出，Service的生命周期相当简单：整个生命周期从调用 onCreate() 开始起，到 onDestroy() 返回时结束。对于非绑定服务，就是从startService调用到stopService或者stopSelf调用。对于绑定服务，就是bindService调用到unbindService调用；</p><p>如果要手动控制Service组件的生命周期，我们只需要模拟出这个过程即可；而实现这一点并不复杂：</p><ol><li>如果以startService方式启动插件Service，直接回调要启动的Service对象的onStartCommand方法即可；如果用stopService或者stopSelf的方式停止Service，只需要回调对应的Service组件的onDestroy方法。</li><li>如果用bindService方式绑定插件Service，可以调用对应Service对应的onBind方法，获取onBind方法返回的Binder对象，然后通过ServiceConnection对象进行回调统计；unBindService的实现同理。</li></ol><h4 id="完全手动控制"><a href="#完全手动控制" class="headerlink" title="完全手动控制"></a>完全手动控制</h4><p>现在我们已经有了实现思路，那么具体如何实现呢？</p><p>我们必须在startService,stopService等方法被调用的时候拿到控制权，才能手动去控制Service的生命周期；要达到这一目的非常简单——Hook ActivityManagerNative即可。在Activity的插件化方案中我们就通过这种方式接管了startActivity调用，相信读者并不陌生。</p><p>我们Hook掉ActivityManagerNative之后，可以拦截对于startService以及stopService等方法的调用；拦截之后，我们可以直接对插件Service进行操作：</p><ol><li>拦截到startService之后，如果Service还没有创建就直接创建Service对象（可能需要加载插件），然后调用这个Service的onCreate,onStartCommond方法；如果Service已经创建，获取到原来创建的Service对象并执行其onStartCommand方法。</li><li>拦截到stopService之后，获取到对应的Service对象，直接调用这个Service的onDestroy方法。</li></ol><p>这种方案简直简单得让人不敢相信！很可惜，这么干是不行的。</p><p>首先，Service存在的意义在于它作为一个后台任务，拥有相对较高运行时优先级；除非在内存及其不足威胁到前台Activity的时候，这个组件才会被系统杀死。上述这种实现完全把Service当作一个普通的Java对象使用了，因此并没有完全实现Service所具备的能力。</p><p>其次，Activity以及Service等组件是可以指定进程的，而让Service运行在某个特定进程的情况非常常见——所谓的远程Service；用上述这种办法压根儿没有办法让某个Service对象运行在一个别的进程。Android系统给开发者控制进程的机会太少了，要么在AndroidManifest.xml中通过process属性指定，要么借助Java的Runtime类或者native的fork；这几种方式都无法让我们以一种简单的方式配合上述方案达到目的。</p><h4 id="代理分发技术"><a href="#代理分发技术" class="headerlink" title="代理分发技术"></a>代理分发技术</h4><p>既然我们希望插件的Service具有一定的运行时优先级，那么一个货真价实的Service组件是必不可少的——只有这种被系统认可的真正的Service组件才具有所谓的运行时优先级。</p><p>因此，我们可以注册一个真正的Service组件ProxyService，让这个Service承载一个真正的Service组件所具备的能力（进程优先级等）；当启动插件的服务比如PluginService的时候，我们统一启动这个ProxyService，当这个ProxyService运行起来之后，再在它的onStartCommand等方法里面进行分发，执行PluginService的onStartCommond等对应的方法；我们把这种方案形象地称为「代理分发技术」</p><p>代理分发技术也可以完美解决插件Service可以运行在不同的进程的问题——我们可以在AndroidManifest.xml中注册多个ProxyService，指定它们的process属性，让它们运行在不同的进程；当启动的插件Service希望运行在一个新的进程时，我们可以选择某一个合适的ProxyService进行分发。也许有童鞋会说，那得注册多少个ProxyService才能满足需求啊？理论上确实存在这问题，但事实上，一个App使用超过10个进程的几乎没有；因此这种方案是可行的。</p><h2 id="Service插件化的实现"><a href="#Service插件化的实现" class="headerlink" title="Service插件化的实现"></a>Service插件化的实现</h2><p>现在我们已经设计出了Service组件的插件化方案，接下来我们以startService以及stopService为例实现这个过程。</p><h3 id="注册代理Service"><a href="#注册代理Service" class="headerlink" title="注册代理Service"></a>注册代理Service</h3><p>我们需要一个货真价实的Service组件来承载进程优先级等功能，因此需要在AndroidManifest.xml中声明一个或者多个（用以支持多进程）这样的Sevice：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.weishu.upf.service_management.app.ProxyService"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:process</span>=<span class="string">"plugin01"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="拦截startService等调用过程"><a href="#拦截startService等调用过程" class="headerlink" title="拦截startService等调用过程"></a>拦截startService等调用过程</h3><p>要手动控制Service组件的生命周期，需要拦截startService,stopService等调用，并且把启动插件Service全部重定向为启动ProxyService（保留原始插件Service信息）；这个拦截过程需要Hook ActvityManagerNative，我们对这种技术应该是轻车熟路了；不了解的童鞋可以参考之前的文章 <a href="Hook机制之AMS&amp;PMS.md">Hook机制之AMS&amp;PMS</a> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookActivityManagerNative</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException,</span></span><br><span class="line"><span class="function">        NoSuchMethodException, InvocationTargetException,</span></span><br><span class="line"><span class="function">        IllegalAccessException, NoSuchFieldException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; activityManagerNativeClass = Class.forName(<span class="string">"android.app.ActivityManagerNative"</span>);</span><br><span class="line"></span><br><span class="line">    Field gDefaultField = activityManagerNativeClass.getDeclaredField(<span class="string">"gDefault"</span>);</span><br><span class="line">    gDefaultField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    Object gDefault = gDefaultField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gDefault是一个 android.util.Singleton对象; 我们取出这个单例里面的字段</span></span><br><span class="line">    Class&lt;?&gt; singleton = Class.forName(<span class="string">"android.util.Singleton"</span>);</span><br><span class="line">    Field mInstanceField = singleton.getDeclaredField(<span class="string">"mInstance"</span>);</span><br><span class="line">    mInstanceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ActivityManagerNative 的gDefault对象里面原始的 IActivityManager对象</span></span><br><span class="line">    Object rawIActivityManager = mInstanceField.get(gDefault);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个这个对象的代理对象, 然后替换这个字段, 让我们的代理对象帮忙干活</span></span><br><span class="line">    Class&lt;?&gt; iActivityManagerInterface = Class.forName(<span class="string">"android.app.IActivityManager"</span>);</span><br><span class="line">    Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> Class&lt;?&gt;[] &#123; iActivityManagerInterface &#125;, <span class="keyword">new</span> IActivityManagerHandler(rawIActivityManager));</span><br><span class="line">    mInstanceField.set(gDefault, proxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在收到startService,stopService之后可以进行具体的操作，对于startService来说，就是直接替换启动的插件Service为ProxyService等待后续处理，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">"startService"</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="comment">// API 23:</span></span><br><span class="line">    <span class="comment">// public ComponentName startService(IApplicationThread caller, Intent service,</span></span><br><span class="line">    <span class="comment">//        String resolvedType, int userId) throws RemoteException</span></span><br><span class="line">    <span class="comment">// 找到参数里面的第一个Intent 对象</span></span><br><span class="line">    Pair&lt;Integer, Intent&gt; integerIntentPair = foundFirstIntentOfArgs(args);</span><br><span class="line">    Intent newIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">    <span class="comment">// 代理Service的包名, 也就是我们自己的包名</span></span><br><span class="line">    String stubPackage = UPFApplication.getContext().getPackageName();</span><br><span class="line">    <span class="comment">// 这里我们把启动的Service替换为ProxyService, 让ProxyService接收生命周期回调</span></span><br><span class="line">    ComponentName componentName = <span class="keyword">new</span> ComponentName(stubPackage, ProxyService.class.getName());</span><br><span class="line">    newIntent.setComponent(componentName);</span><br><span class="line">    <span class="comment">// 把我们原始要启动的TargetService先存起来</span></span><br><span class="line">    newIntent.putExtra(AMSHookHelper.EXTRA_TARGET_INTENT, integerIntentPair.second);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换掉Intent, 达到欺骗AMS的目的</span></span><br><span class="line">    args[integerIntentPair.first] = newIntent;</span><br><span class="line">    Log.v(TAG, <span class="string">"hook method startService success"</span>);</span><br><span class="line">    <span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对stopService的处理略有不同但是大同小异，读者可以上 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">github</a> 查阅源码。</p><h3 id="分发Service"><a href="#分发Service" class="headerlink" title="分发Service"></a>分发Service</h3><p>Hook ActivityManagerNative之后，所有的插件Service的启动都被重定向了到了我们注册的ProxyService，这样可以保证我们的插件Service有一个真正的Service组件作为宿主；但是要执行特定插件Service的任务，我们必须把这个任务分发到真正要启动的Service上去；以<code>onStart</code>为例，在启动ProxyService之后，会收到ProxyService的<code>onStart</code>回调，我们可以在这个方法里面把具体的任务交给原始要启动的插件Service组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"onStart() called with "</span> + <span class="string">"intent = ["</span> + intent + <span class="string">"], startId = ["</span> + startId + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分发Service</span></span><br><span class="line">    ServiceManager.getInstance().onStart(intent, startId);</span><br><span class="line">    <span class="keyword">super</span>.onStart(intent, startId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加载Service"><a href="#加载Service" class="headerlink" title="加载Service"></a>加载Service</h4><p>我们可以在ProxyService里面把任务转发给真正要启动的插件Service组件，要完成这个过程肯定需要创建一个对应的插件Service对象，比如PluginService；但是通常情况下插件存在与单独的文件之中，正常的方式是无法创建这个PluginService对象的，宿主程序默认的ClassLoader无法加载插件中对应的这个类；所以，要创建这个对应的PluginService对象，必须先完成插件的加载过程，让这个插件中的所有类都可以被正常访问；这种技术我们在之前专门讨论过，并给出了「激进方案」和「保守方案」，不了解的童鞋可以参考文章 <a href="ClassLoader管理.md">插件加载机制</a>；这里我选择代码较少的「保守方案」为例（Droid Plugin中采用的激进方案）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">patchClassLoader</span><span class="params">(ClassLoader cl, File apkFile, File optDexFile)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException, NoSuchMethodException, IOException, InvocationTargetException, InstantiationException, NoSuchFieldException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 BaseDexClassLoader : pathList</span></span><br><span class="line">    Field pathListField = DexClassLoader.class.getSuperclass().getDeclaredField(<span class="string">"pathList"</span>);</span><br><span class="line">    pathListField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object pathListObj = pathListField.get(cl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 PathList: Element[] dexElements</span></span><br><span class="line">    Field dexElementArray = pathListObj.getClass().getDeclaredField(<span class="string">"dexElements"</span>);</span><br><span class="line">    dexElementArray.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object[] dexElements = (Object[]) dexElementArray.get(pathListObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Element 类型</span></span><br><span class="line">    Class&lt;?&gt; elementClass = dexElements.getClass().getComponentType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个数组, 用来替换原始的数组</span></span><br><span class="line">    Object[] newElements = (Object[]) Array.newInstance(elementClass, dexElements.length + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造插件Element(File file, boolean isDirectory, File zip, DexFile dexFile) 这个构造函数</span></span><br><span class="line">    Constructor&lt;?&gt; constructor = elementClass.getConstructor(File.class, <span class="keyword">boolean</span>.class, File.class, DexFile.class);</span><br><span class="line">    Object o = constructor.newInstance(apkFile, <span class="keyword">false</span>, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(), optDexFile.getAbsolutePath(), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    Object[] toAddElementArray = <span class="keyword">new</span> Object[] &#123; o &#125;;</span><br><span class="line">    <span class="comment">// 把原始的elements复制进去</span></span><br><span class="line">    System.arraycopy(dexElements, <span class="number">0</span>, newElements, <span class="number">0</span>, dexElements.length);</span><br><span class="line">    <span class="comment">// 插件的那个element复制进去</span></span><br><span class="line">    System.arraycopy(toAddElementArray, <span class="number">0</span>, newElements, dexElements.length, toAddElementArray.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换</span></span><br><span class="line">    dexElementArray.set(pathListObj, newElements);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h4><p>上文中我们把启动插件Service重定向为启动ProxyService，现在ProxyService已经启动，因此必须把控制权交回原始的PluginService；在加载插件的时候，我们存储了插件中所有的Service组件的信息，因此，只需要根据Intent里面的Component信息就可以取出对应的PluginService。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ServiceInfo <span class="title">selectPluginService</span><span class="params">(Intent pluginIntent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ComponentName componentName : mServiceInfoMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (componentName.equals(pluginIntent.getComponent())) &#123;</span><br><span class="line">            <span class="keyword">return</span> mServiceInfoMap.get(componentName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建以及分发"><a href="#创建以及分发" class="headerlink" title="创建以及分发"></a>创建以及分发</h4><p>插件被加载之后，我们就需要创建插件Service对应的Java对象了；由于这些类是在运行时动态加载进来的，肯定不能直接使用<code>new</code>关键字——我们需要使用反射机制。但是下面的代码创建出插件Service对象能满足要求吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl = getClassLoader();</span><br><span class="line">Service service = cl.loadClass(<span class="string">"com.plugin.xxx.PluginService1"</span>);</span><br></pre></td></tr></table></figure><p>Service作为Android系统的组件，最重要的特点是它具有<code>Context</code>；所以，直接通过反射创建出来的这个PluginService就是一个壳子——没有Context的Service能干什么？因此我们需要给将要创建的Service类创建出Conetxt；但是Context应该如何创建呢？我们平时压根儿没有这么干过，Context都是系统给我们创建好的。既然这样，我们可以参照一下系统是如何创建Service对象的；在上文的Service源码分析中，在ActivityThread类的handleCreateService完成了这个步骤，摘要如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">    service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">    context.setOuterContext(service);</span><br><span class="line"></span><br><span class="line">    Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">    service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,</span><br><span class="line">            ActivityManagerNative.getDefault());</span><br><span class="line">    service.onCreate();</span><br></pre></td></tr></table></figure><p>可以看到，系统也是通过反射创建出了对应的Service对象，然后也创建了对应的Context，并给Service注入了活力。如果我们模拟系统创建Context这个过程，势必需要进行一系列反射调用，那么我们何不直接反射handleCreateService方法呢？</p><p>当然，handleCreateService这个方法并没有把创建出来的Service对象作为返回值返回，而是存放在ActivityThread的成员变量<code>mService</code>之中，这个是小case，我们反射取出来就行；所以，创建Service对象的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过ActivityThread的handleCreateService方法创建出Service对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> serviceInfo 插件的ServiceInfo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">proxyCreateService</span><span class="params">(ServiceInfo serviceInfo)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    IBinder token = <span class="keyword">new</span> Binder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建CreateServiceData对象, 用来传递给ActivityThread的handleCreateService 当作参数</span></span><br><span class="line">    Class&lt;?&gt; createServiceDataClass = Class.forName(<span class="string">"android.app.ActivityThread$CreateServiceData"</span>);</span><br><span class="line">    Constructor&lt;?&gt; constructor  = createServiceDataClass.getDeclaredConstructor();</span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object createServiceData = constructor.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入我们创建的createServiceData的token字段, ActivityThread的handleCreateService用这个作为key存储Service</span></span><br><span class="line">    Field tokenField = createServiceDataClass.getDeclaredField(<span class="string">"token"</span>);</span><br><span class="line">    tokenField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    tokenField.set(createServiceData, token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入info对象</span></span><br><span class="line">    <span class="comment">// 这个修改是为了loadClass的时候, LoadedApk会是主程序的ClassLoader, 我们选择Hook BaseDexClassLoader的方式加载插件</span></span><br><span class="line">    serviceInfo.applicationInfo.packageName = UPFApplication.getContext().getPackageName();</span><br><span class="line">    Field infoField = createServiceDataClass.getDeclaredField(<span class="string">"info"</span>);</span><br><span class="line">    infoField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    infoField.set(createServiceData, serviceInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入compatInfo字段</span></span><br><span class="line">    <span class="comment">// 获取默认的compatibility配置</span></span><br><span class="line">    Class&lt;?&gt; compatibilityClass = Class.forName(<span class="string">"android.content.res.CompatibilityInfo"</span>);</span><br><span class="line">    Field defaultCompatibilityField = compatibilityClass.getDeclaredField(<span class="string">"DEFAULT_COMPATIBILITY_INFO"</span>);</span><br><span class="line">    Object defaultCompatibility = defaultCompatibilityField.get(<span class="keyword">null</span>);</span><br><span class="line">    Field compatInfoField = createServiceDataClass.getDeclaredField(<span class="string">"compatInfo"</span>);</span><br><span class="line">    compatInfoField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    compatInfoField.set(createServiceData, defaultCompatibility);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">    Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">    Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private void handleCreateService(CreateServiceData data) &#123;</span></span><br><span class="line">    Method handleCreateServiceMethod = activityThreadClass.getDeclaredMethod(<span class="string">"handleCreateService"</span>, createServiceDataClass);</span><br><span class="line">    handleCreateServiceMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    handleCreateServiceMethod.invoke(currentActivityThread, createServiceData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handleCreateService创建出来的Service对象并没有返回, 而是存储在ActivityThread的mServices字段里面, 这里我们手动把它取出来</span></span><br><span class="line">    Field mServicesField = activityThreadClass.getDeclaredField(<span class="string">"mServices"</span>);</span><br><span class="line">    mServicesField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Map mServices = (Map) mServicesField.get(currentActivityThread);</span><br><span class="line">    Service service = (Service) mServices.get(token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到之后, 移除这个service, 我们只是借花献佛</span></span><br><span class="line">    mServices.remove(token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将此Service存储起来</span></span><br><span class="line">    mServiceMap.put(serviceInfo.name, service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经创建出了对应的PluginService，并且拥有至关重要的Context对象；接下来就可以把消息分发给原始的PluginService组件了，这个分发的过程很简单，直接执行消息对应的回调(onStart, onDestroy等）即可；因此，完整的startService分发过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent proxyIntent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Intent targetIntent = proxyIntent.getParcelableExtra(AMSHookHelper.EXTRA_TARGET_INTENT);</span><br><span class="line">    ServiceInfo serviceInfo = selectPluginService(targetIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (serviceInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"can not found service : "</span> + targetIntent.getComponent());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mServiceMap.containsKey(serviceInfo.name)) &#123;</span><br><span class="line">            <span class="comment">// service还不存在, 先创建</span></span><br><span class="line">            proxyCreateService(serviceInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Service service = mServiceMap.get(serviceInfo.name);</span><br><span class="line">        service.onStart(targetIntent, startId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们已经实现了Service组件的插件化；完整的代码见 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">github</a>，代码以startService, stopService为例进行了说明，bindService以及unbindService的原理是一样的，感兴趣的读者可以自行实现；欢迎PR。</p><h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>本文中我们以绑定服务为例分析了Service组件的工作原理，并指出用户交导致组件生命周期的变化是Activity与Service的根本差别，这种差别使得插件方案对于它们必须采取不同的处理方式；最后我们通过手动控制Service组件的生命周期结合「代理分发技术」成功地实现了Service组件的插件化；这种插件化方案堪称「完美」，如果非要吹毛求疵，那只能说由于同一个进程的所有Service都挂载在同一个ProxyService上面，如果系统可用内存不够必须回收Service，杀死一个ProxyService会导致一大票的插件Service歇菜。</p><p>实际使用过程中，Service组件的更新频度并不高，因此直接把插件Service注册到主程序也是可以接受的；而且如果需要绑定远程Service，完全可以使用一个Service组件根据不同的Intent返回不同的IBinder，所以不实现Service组件的插件化也能满足工程需要。值得一提的是，我们对于Service组件的插件化方案实际上是一种「代理」的方式，用这种方式也能实现Activity组件的插件化，有一些开源的插件方案比如 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="noopener">DL</a> 就是这么做的。</p><p>迄今为止，我们讲述了了Activity、BroadcastReceiver以及Service的插件化方式，不知读者思索过没有，实现插件化的关键点在哪里？</p><p>Service，Activity等不过就是一些普通的Java类，它们之所称为四大组件，是因为他们有生命周期；这也是简单地采用Java的动态加载技术无法实现插件化的原因——动态加载进来的Service等类如果没有它的生命周期，无异于一个没有灵魂的傀儡。对于Activity组件，由于他的生命周期受用户交互影响，只有系统本身才能对这种交互有全局掌控力，因此它的插件化方式是Hook AMS，但是生命周期依然交由系统管理；而Service以及BroadcastReceiver的生命周期没有额外的因素影响，因此我们选择了手动控制其生命周期的方式。不论是借尸还魂还是女娲造人，对这些组件的插件化终归结底是要赋予组件“生命”。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Service插件化&quot;&gt;&lt;a href=&quot;#Service插件化&quot; class=&quot;headerlink&quot; title=&quot;Service插件化&quot;&gt;&lt;/a&gt;Service插件化&lt;/h1&gt;&lt;p&gt;在 &lt;a href=&quot;Activity生命周期管理.md&quot;&gt;Activity生命周期管理&lt;/a&gt; 以及 &lt;a href=&quot;BroadcastReceiver插件化.md&quot;&gt;广播的管理&lt;/a&gt; 中我们详细探讨了Android系统中的Activity、BroadcastReceiver组件的工作原理以及它们的插件化方案，相信读者已经对Android Framework和插件化技术有了一定的了解；本文将探讨Android四大组件之一——Service组件的插件化方式。&lt;/p&gt;
&lt;p&gt;与Activity, BroadcastReceiver相比，Service组件的不同点在哪里呢？我们能否用与之相同的方式实现Service的插件化？如果不行，它们的差别在哪里，应该如何实现Service的插件化？&lt;/p&gt;
&lt;p&gt;我们接下来将围绕这几个问题展开，最终给出Service组件的插件化方式；阅读本文之前，可以先clone一份 &lt;a href=&quot;https://github.com/tiann/understand-plugin-framework&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;understand-plugin-framework&lt;/a&gt;，参考此项目的 service-management 模块。另外，插件框架原理解析系列文章见&lt;a href=&quot;概述.md&quot;&gt;索引&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android插件化原理解析——Hook机制之动态代理</title>
    <link href="https://zhanqq2010.github.io/2018/01/11/Hook%E6%9C%BA%E5%88%B6%E4%B9%8B%E4%BB%A3%E7%90%86Hook/"/>
    <id>https://zhanqq2010.github.io/2018/01/11/Hook机制之代理Hook/</id>
    <published>2018-01-11T04:03:39.502Z</published>
    <updated>2018-01-11T04:05:19.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hook机制之动态代理"><a href="#Hook机制之动态代理" class="headerlink" title="Hook机制之动态代理"></a>Hook机制之动态代理</h1><p>使用代理机制进行API Hook进而达到方法增强是框架的常用手段，比如J2EE框架Spring通过动态代理优雅地实现了AOP编程，极大地提升了Web开发效率；同样，插件框架也广泛使用了代理机制来增强系统API从而达到插件化的目的。本文将带你了解基于动态代理的Hook机制。</p><p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>，参考此项目的<code>dynamic-proxy-hook</code>模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/" target="_blank" rel="noopener">索引</a>。</p><h2 id="代理是什么"><a href="#代理是什么" class="headerlink" title="代理是什么"></a>代理是什么</h2><p>为什么需要代理呢？其实这个代理与日常生活中的“代理”，“中介”差不多；比如你想海淘买东西，总不可能亲自飞到国外去购物吧，这时候我们使用第三方海淘服务比如惠惠购物助手等；同样拿购物为例，有时候第三方购物会有折扣比如当初的米折网，这时候我们可以少花点钱；当然有时候这个“代理”比较坑，坑我们的钱，坑我们的货。</p><p>从这个例子可以看出来，代理可以实现<strong>方法增强</strong>，比如常用的<em>日志</em>,<em>缓存</em>等；也可以实现方法拦截，通过代理方法修改原方法的参数和返回值，从而实现某种不可告人的目的～接下来我们用代码解释一下。<br><a id="more"></a></p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理，是最原始的代理方式；假设我们有一个购物的接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">    Object[] doShopping(<span class="keyword">long</span> money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它有一个原始的实现，我们可以理解为亲自，直接去商店购物：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingImpl</span> <span class="keyword">implements</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] doShopping(<span class="keyword">long</span> money) &#123;</span><br><span class="line">        System.out.println(<span class="string">"逛淘宝 ,逛商场,买买买!!"</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"花了%s块钱"</span>, money));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Object[] &#123; <span class="string">"鞋子"</span>, <span class="string">"衣服"</span>, <span class="string">"零食"</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在我们自己没时间但是需要买东西，于是我们就找了个代理帮我们买：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyShopping</span> <span class="keyword">implements</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Shopping base;</span><br><span class="line"></span><br><span class="line">    ProxyShopping(Shopping base) &#123;</span><br><span class="line">        <span class="keyword">this</span>.base = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] doShopping(<span class="keyword">long</span> money) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先黑点钱(修改输入参数)</span></span><br><span class="line">        <span class="keyword">long</span> readCost = (<span class="keyword">long</span>) (money * <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(String.format(<span class="string">"花了%s块钱"</span>, readCost));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 帮忙买东西</span></span><br><span class="line">        Object[] things = base.doShopping(readCost);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偷梁换柱(修改返回值)</span></span><br><span class="line">        <span class="keyword">if</span> (things != <span class="keyword">null</span> &amp;&amp; things.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            things[<span class="number">0</span>] = <span class="string">"被掉包的东西!!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> things;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>很不幸，我们找的这个代理有点坑，坑了我们的钱还坑了我们的货；先忍忍。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>传统的静态代理模式需要为每一个需要代理的类写一个代理类，如果需要代理的类有几百个那不是要累死？为了更优雅地实现代理模式，JDK提供了动态代理方式，可以简单理解为JVM可以在运行时帮我们动态生成一系列的代理类，这样我们就不需要手写每一个静态的代理类了。依然以购物为例，用动态代理实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Shopping women = <span class="keyword">new</span> ShoppingImpl();</span><br><span class="line">    <span class="comment">// 正常购物</span></span><br><span class="line">    System.out.println(Arrays.toString(women.doShopping(<span class="number">100</span>)));</span><br><span class="line">    <span class="comment">// 招代理</span></span><br><span class="line">    women = (Shopping) Proxy.newProxyInstance(Shopping.class.getClassLoader(),</span><br><span class="line">            women.getClass().getInterfaces(), <span class="keyword">new</span> ShoppingHandler(women));</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(women.doShopping(<span class="number">100</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理主要处理<code>InvocationHandler</code>和<code>Proxy</code>类；完整代码可以见<a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">github</a></p><h2 id="代理Hook"><a href="#代理Hook" class="headerlink" title="代理Hook"></a>代理Hook</h2><p>我们知道代理有比原始对象更强大的能力，比如飞到国外买东西，比如坑钱坑货；那么很自然，如果我们自己创建代理对象，然后把原始对象替换为我们的代理对象，那么就可以在这个代理对象为所欲为了；修改参数，替换返回值，我们称之为Hook。</p><p>下面我们Hook掉<code>startActivity</code>这个方法，使得每次调用这个方法之前输出一条日志；（当然，这个输入日志有点点弱，只是为了展示原理；只要你想，你想可以替换参数，拦截这个<code>startActivity</code>过程，使得调用它导致启动某个别的Activity，指鹿为马！）</p><p>首先我们得找到被Hook的对象，我称之为Hook点；什么样的对象比较好Hook呢？自然是<strong>容易找到的对象</strong>。什么样的对象容易找到？<strong>静态变量和单例</strong>；在一个进程之内，静态变量和单例变量是相对不容易发生变化的，因此非常容易定位，而普通的对象则要么无法标志，要么容易改变。我们根据这个原则找到所谓的Hook点。</p><p>然后我们分析一下<code>startActivity</code>的调用链，找出合适的Hook点。我们知道对于<code>Context.startActivity</code>（Activity.startActivity的调用链与之不同），由于<code>Context</code>的实现实际上是<code>ContextImpl</code>;我们看<code>ConetxtImpl</code>类的<code>startActivity</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(</span><br><span class="line">                <span class="string">"Calling startActivity() from outside of an Activity "</span></span><br><span class="line">                + <span class="string">" context requires the FLAG_ACTIVITY_NEW_TASK flag."</span></span><br><span class="line">                + <span class="string">" Is this really what you want?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">        getOuterContext(), mMainThread.getApplicationThread(), <span class="keyword">null</span>,</span><br><span class="line">        (Activity)<span class="keyword">null</span>, intent, -<span class="number">1</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，实际上使用了<code>ActivityThread</code>类的<code>mInstrumentation</code>成员的<code>execStartActivity</code>方法；注意到，<code>ActivityThread</code> 实际上是主线程，而主线程一个进程只有一个，因此这里是一个良好的Hook点。</p><p>接下来就是想要Hook掉我们的主线程对象，也就是把这个主线程对象里面的<code>mInstrumentation</code>给替换成我们修改过的代理对象；要替换主线程对象里面的字段，首先我们得拿到主线程对象的引用，如何获取呢？<code>ActivityThread</code>类里面有一个静态方法<code>currentActivityThread</code>可以帮助我们拿到这个对象类；但是<code>ActivityThread</code>是一个隐藏类，我们需要用反射去获取，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取到当前的ActivityThread对象</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>拿到这个<code>currentActivityThread</code>之后，我们需要修改它的<code>mInstrumentation</code>这个字段为我们的代理对象，我们先实现这个代理对象，由于JDK动态代理只支持接口，而这个<code>Instrumentation</code>是一个类，没办法，我们只有手动写静态代理类，覆盖掉原始的方法即可。（<code>cglib</code>可以做到基于类的动态代理，这里先不介绍）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilInstrumentation</span> <span class="keyword">extends</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"EvilInstrumentation"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ActivityThread中原始的对象, 保存起来</span></span><br><span class="line">    Instrumentation mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvilInstrumentation</span><span class="params">(Instrumentation base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hook之前, XXX到此一游!</span></span><br><span class="line">        Log.d(TAG, <span class="string">"\n执行了startActivity, 参数如下: \n"</span> + <span class="string">"who = ["</span> + who + <span class="string">"], "</span> +</span><br><span class="line">                <span class="string">"\ncontextThread = ["</span> + contextThread + <span class="string">"], \ntoken = ["</span> + token + <span class="string">"], "</span> +</span><br><span class="line">                <span class="string">"\ntarget = ["</span> + target + <span class="string">"], \nintent = ["</span> + intent +</span><br><span class="line">                <span class="string">"], \nrequestCode = ["</span> + requestCode + <span class="string">"], \noptions = ["</span> + options + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始调用原始的方法, 调不调用随你,但是不调用的话, 所有的startActivity都失效了.</span></span><br><span class="line">        <span class="comment">// 由于这个方法是隐藏的,因此需要使用反射调用;首先找到这个方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method execStartActivity = Instrumentation.class.getDeclaredMethod(</span><br><span class="line">                    <span class="string">"execStartActivity"</span>,</span><br><span class="line">                    Context.class, IBinder.class, IBinder.class, Activity.class,</span><br><span class="line">                    Intent.class, <span class="keyword">int</span>.class, Bundle.class);</span><br><span class="line">            execStartActivity.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (ActivityResult) execStartActivity.invoke(mBase, who,</span><br><span class="line">                    contextThread, token, target, intent, requestCode, options);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 某该死的rom修改了  需要手动适配</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"do not support!!! pls adapt it"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ok，有了代理对象，我们要做的就是偷梁换柱！代码比较简单，采用反射直接修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attachContext</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 先获取到当前的ActivityThread对象</span></span><br><span class="line">    Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">    Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">    currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到原始的 mInstrumentation字段</span></span><br><span class="line">    Field mInstrumentationField = activityThreadClass.getDeclaredField(<span class="string">"mInstrumentation"</span>);</span><br><span class="line">    mInstrumentationField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Instrumentation mInstrumentation = (Instrumentation) mInstrumentationField.get(currentActivityThread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">    Instrumentation evilInstrumentation = <span class="keyword">new</span> EvilInstrumentation(mInstrumentation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偷梁换柱</span></span><br><span class="line">    mInstrumentationField.set(currentActivityThread, evilInstrumentation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，我们启动一个Activity测试一下，结果如下：</p><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1453981415720.png" width="866"></p><p>可见，Hook确实成功了！这就是使用代理进行Hook的原理——偷梁换柱。整个Hook过程简要总结如下：</p><ol><li>寻找Hook点，原则是静态变量或者单例对象，尽量Hook pulic的对象和方法，非public不保证每个版本都一样，需要适配。</li><li>选择合适的代理方式，如果是接口可以用动态代理；如果是类可以手动写代理也可以使用cglib。</li><li>偷梁换柱——用代理对象替换原始对象</li></ol><p>完整代码参照：<a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>；里面留有一个作业：我们目前仅Hook了<code>Context</code>类的<code>startActivity</code>方法，但是<code>Activity</code>类却使用了自己的<code>mInstrumentation</code>；你可以尝试Hook掉Activity类的<code>startActivity</code>方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hook机制之动态代理&quot;&gt;&lt;a href=&quot;#Hook机制之动态代理&quot; class=&quot;headerlink&quot; title=&quot;Hook机制之动态代理&quot;&gt;&lt;/a&gt;Hook机制之动态代理&lt;/h1&gt;&lt;p&gt;使用代理机制进行API Hook进而达到方法增强是框架的常用手段，比如J2EE框架Spring通过动态代理优雅地实现了AOP编程，极大地提升了Web开发效率；同样，插件框架也广泛使用了代理机制来增强系统API从而达到插件化的目的。本文将带你了解基于动态代理的Hook机制。&lt;/p&gt;
&lt;p&gt;阅读本文之前，可以先clone一份 &lt;a href=&quot;https://github.com/tiann/understand-plugin-framework&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;understand-plugin-framework&lt;/a&gt;，参考此项目的&lt;code&gt;dynamic-proxy-hook&lt;/code&gt;模块。另外，插件框架原理解析系列文章见&lt;a href=&quot;http://weishu.me/2016/01/28/understand-plugin-framework-overview/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;索引&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;代理是什么&quot;&gt;&lt;a href=&quot;#代理是什么&quot; class=&quot;headerlink&quot; title=&quot;代理是什么&quot;&gt;&lt;/a&gt;代理是什么&lt;/h2&gt;&lt;p&gt;为什么需要代理呢？其实这个代理与日常生活中的“代理”，“中介”差不多；比如你想海淘买东西，总不可能亲自飞到国外去购物吧，这时候我们使用第三方海淘服务比如惠惠购物助手等；同样拿购物为例，有时候第三方购物会有折扣比如当初的米折网，这时候我们可以少花点钱；当然有时候这个“代理”比较坑，坑我们的钱，坑我们的货。&lt;/p&gt;
&lt;p&gt;从这个例子可以看出来，代理可以实现&lt;strong&gt;方法增强&lt;/strong&gt;，比如常用的&lt;em&gt;日志&lt;/em&gt;,&lt;em&gt;缓存&lt;/em&gt;等；也可以实现方法拦截，通过代理方法修改原方法的参数和返回值，从而实现某种不可告人的目的～接下来我们用代码解释一下。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android插件化原理解析——Hook机制之Binder-Hook</title>
    <link href="https://zhanqq2010.github.io/2018/01/11/Hook%E6%9C%BA%E5%88%B6%E4%B9%8BBinder-Hook/"/>
    <id>https://zhanqq2010.github.io/2018/01/11/Hook机制之Binder-Hook/</id>
    <published>2018-01-11T04:03:39.499Z</published>
    <updated>2018-01-11T04:05:29.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hook机制之Binder-Hook"><a href="#Hook机制之Binder-Hook" class="headerlink" title="Hook机制之Binder-Hook"></a>Hook机制之Binder-Hook</h1><p>Android系统通过Binder机制给应用程序提供了一系列的系统服务，诸如<code>ActivityManagerService</code>，<code>ClipboardManager</code>， <code>AudioManager</code>等；这些广泛存在系统服务给应用程序提供了诸如任务管理，音频，视频等异常强大的功能。</p><p>插件框架作为各个插件的管理者，为了使得插件能够<strong>无缝地</strong>使用这些系统服务，自然会对这些系统服务做出一定的改造(Hook)，使得插件的开发和使用更加方便，从而大大降低插件的开发和维护成本。比如，Hook住<code>ActivityManagerService</code>可以让插件无缝地使用<code>startActivity</code>方法而不是使用特定的方式(比如that语法)来启动插件或者主程序的任意界面。</p><p>我们把这种Hook系统服务的机制称之为Binder Hook，因为本质上这些服务提供者都是存在于系统各个进程的Binder对象。因此，要理解接下来的内容必须了解Android的Binder机制，可以参考我之前的文章<a href="http://weishu.me/2016/01/12/binder-index-for-newer/" target="_blank" rel="noopener">Binder学习指南</a></p><a id="more"></a><p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>，参考此项目的<code>binder-hook</code> 模块。另外，插件框架原理解析系列文章见<a href="概述.md">索引</a>。</p><h2 id="系统服务的获取过程"><a href="#系统服务的获取过程" class="headerlink" title="系统服务的获取过程"></a>系统服务的获取过程</h2><p>我们知道系统的各个远程service对象都是以Binder的形式存在的，而这些Binder有一个管理者，那就是<code>ServiceManager</code>；我们要Hook掉这些service，自然要从这个<code>ServiceManager</code>下手，不然星罗棋布的Binder广泛存在于系统的各个角落，要一个个找出来还真是大海捞针。</p><p>回想一下我们使用系统服务的时候是怎么干的，想必这个大家一定再熟悉不过了：通过<code>Context</code>对象的<code>getSystemService</code>方法；比如要使用<code>ActivityManager</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</span><br></pre></td></tr></table></figure><p>可是这个貌似跟<code>ServiceManager</code>没有什么关系啊？我们再查看<code>getSystemService</code>方法；(Context的实现在<code>ContextImpl</code>里面)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    ServiceFetcher fetcher = SYSTEM_SERVICE_MAP.get(name);</span><br><span class="line">    <span class="keyword">return</span> fetcher == <span class="keyword">null</span> ? <span class="keyword">null</span> : fetcher.getService(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，所有的service对象都保存在一张<code>map</code>里面，我们再看这个map是怎么初始化的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registerService(ACCOUNT_SERVICE, new ServiceFetcher() &#123;</span><br><span class="line">                public Object createService(ContextImpl ctx) &#123;</span><br><span class="line">                    IBinder b = ServiceManager.getService(ACCOUNT_SERVICE);</span><br><span class="line">                    IAccountManager service = IAccountManager.Stub.asInterface(b);</span><br><span class="line">                    return new AccountManager(ctx, service);</span><br><span class="line">                &#125;&#125;);</span><br></pre></td></tr></table></figure><p>在<code>ContextImpl</code>的静态初始化块里面，有的Service是像上面这样初始化的；可以看到，确实使用了<code>ServiceManager</code>；当然还有一些service并没有直接使用<code>ServiceManager</code>，而是做了一层包装并返回了这个包装对象，比如我们的<code>ActivityManager</code>，它返回的是<code>ActivityManager</code>这个包装对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">registerService(ACTIVITY_SERVICE, new ServiceFetcher() &#123;</span><br><span class="line">                public Object createService(ContextImpl ctx) &#123;</span><br><span class="line">                    return new ActivityManager(ctx.getOuterContext(), ctx.mMainThread.getHandler());</span><br><span class="line">                &#125;&#125;);</span><br></pre></td></tr></table></figure><p>但是在<code>ActivityManager</code>这个类内部，也使用了<code>ServiceManager</code>；具体来说，因为ActivityManager里面所有的核心操作都是使用<code>ActivityManagerNative.getDefault()</code>完成的。那么这个语句干了什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);</span><br><span class="line">            IActivityManager am = asInterface(b);</span><br><span class="line">            <span class="keyword">return</span> am;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>因此，通过分析我们得知，系统Service的使用其实就分为两步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IBinder b = ServiceManager.getService(<span class="string">"service_name"</span>); <span class="comment">// 获取原始的IBinder对象</span></span><br><span class="line">IXXInterface in = IXXInterface.Stub.asInterface(b); <span class="comment">// 转换为Service接口</span></span><br></pre></td></tr></table></figure><h2 id="寻找Hook点"><a href="#寻找Hook点" class="headerlink" title="寻找Hook点"></a>寻找Hook点</h2><p>在<a href="Hook机制之代理Hook.md">插件框架原理解析——Hook机制之动态代理</a>里面我们说过，Hook分为三步，最关键的一步就是寻找Hook点。我们现在已经搞清楚了系统服务的使用过程，那么就需要找出在这个过程中，在哪个环节是最合适hook的。</p><p>由于系统服务的使用者都是对第二步获取到的<code>IXXInterface</code>进行操作，因此如果我们要hook掉某个系统服务，<strong>只需要把第二步的<code>asInterface</code>方法返回的对象修改为为我们Hook过的对象就可以了。</strong></p><h3 id="asInterface过程"><a href="#asInterface过程" class="headerlink" title="asInterface过程"></a>asInterface过程</h3><p>接下来我们分析<code>asInterface</code>方法，然后想办法把这个方法的返回值修改为我们Hook过的系统服务对象。这里我们以系统剪切版服务为例，源码位置为<code>android.content.IClipboard</code>,<code>IClipboard.Stub.asInterface</code>方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> android.content.<span class="function">IClipboard <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); <span class="comment">// Hook点</span></span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> android.content.IClipboard))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((android.content.IClipboard) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> android.content.IClipboard.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的意思就是：先查看本进程是否存在这个Binder对象，如果有那么直接就是本进程调用了；如果不存在那么创建一个代理对象，让代理对象委托驱动完成跨进程调用。</p><p>观察这个方法，前面的那个if语句判空返回肯定动不了手脚；最后一句调用构造函数然后直接返回我们也是无从下手，要修改<code>asInterface</code>方法的返回值，我们唯一能做的就是从这一句下手：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); // Hook点</span><br></pre></td></tr></table></figure><p>我们可以尝试修改这个<code>obj</code>对象的<code>queryLocalInterface</code>方法的返回值，并保证这个返回值符合接下来的<code>if</code>条件检测，那么就达到了修改<code>asInterface</code>方法返回值的目的。</p><p>而这个<code>obj</code>对象刚好是我们第一步返回的<code>IBinder</code>对象，接下来我们尝试对这个<code>IBinder</code>对象的<code>queryLocalInterface</code>方法进行hook。</p><h3 id="getService过程"><a href="#getService过程" class="headerlink" title="getService过程"></a>getService过程</h3><p>上文分析得知，我们想要修改<code>IBinder</code>对象的<code>queryLocalInterface</code>方法；获取<code>IBinder</code>对象的过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IBinder b = ServiceManager.getService(&quot;service_name&quot;);</span><br></pre></td></tr></table></figure><p>因此，我们希望能修改这个<code>getService</code>方法的返回值，让这个方法返回一个我们伪造过的<code>IBinder</code>对象；这样，我们可以在自己伪造的<code>IBinder</code>对象的<code>queryLocalInterface</code>方法作处理，进而使得<code>asInterface</code>方法返回在<code>queryLocalInterface</code>方法里面处理过的值，最终实现hook系统服务的目的。</p><p>在跟踪这个<code>getService</code>方法之前我们思考一下，由于系统服务是一系列的远程Service，它们的本体，也就是Binder本地对象一般都存在于某个单独的进程，在这个进程之外的其他进程存在的都是这些Binder本地对象的代理。因此在我们的进程里面，存在的也只是这个Binder代理对象，我们也只能对这些Binder代理对象下手。(如果这一段看不懂，建议不要往下看了，先看<a href="http://weishu.me/2016/01/12/binder-index-for-newer/" target="_blank" rel="noopener">Binder学习指南</a>)</p><p>然后，这个<code>getService</code>是一个静态方法，如果此方法什么都不做，拿到Binder代理对象之后直接返回；那么我们就无能为力了：我们没有办法拦截一个静态方法，也没有办法获取到这个静态方法里面的局部变量(即我们希望修改的那个Binder代理对象)。</p><p>接下来就可以看这个<code>getService</code>的代码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IBinder <span class="title">getService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IBinder service = sCache.get(name);</span><br><span class="line">        <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> service;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getIServiceManager().getService(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"error in getService"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>天无绝人之路！<code>ServiceManager</code>为了避免每次都进行跨进程通信，把这些Binder代理对象缓存在一张<code>map</code>里面。</p><p>我们可以替换这个map里面的内容为Hook过的<code>IBinder</code>对象，由于系统在<code>getService</code>的时候每次都会优先查找缓存，因此返回给使用者的都是被我们修改过的对象，从而达到瞒天过海的目的。</p><p>总结一下，要达到修改系统服务的目的，我们需要如下两步：</p><ol><li>首先肯定需要<strong>伪造一个系统服务对象</strong>，接下来就要想办法让<code>asInterface</code>能够返回我们的这个伪造对象而不是原始的系统服务对象。</li><li>通过上文分析我们知道，只要让<code>getService</code>返回<code>IBinder</code>对象的<code>queryLocalInterface</code>方法直接返回我们伪造过的系统服务对象就能达到目的。所以，我们需要<strong>伪造一个IBinder对象</strong>，主要是修改它的<code>queryLocalInterface</code>方法，让它返回我们伪造的系统服务对象；然后把这个伪造对象放置在<code>ServiceManager</code>的缓存<code>map</code>里面即可。</li></ol><p>我们通过Binder机制的<em>优先查找本地Binder对象</em>的这个特性达到了Hook掉系统服务对象的目的。因此<code>queryLocalInterface</code>也失去了它原本的意义(只查找本地Binder对象，没有本地对象返回null)，这个方法只是一个傀儡，是我们实现hook系统对象的桥梁：我们通过这个“漏洞”让<code>asInterface</code>永远都返回我们伪造过的对象。由于我们接管了<code>asInterface</code>这个方法的全部，我们伪造过的这个系统服务对象不能是只拥有本地Binder对象(原始<code>queryLocalInterface</code>方法返回的对象)的能力，还要有Binder代理对象操纵驱动的能力。</p><p>接下来我们就以Hook系统的剪切版服务为例，用实际代码来说明，如何Hook掉系统服务。</p><h2 id="Hook系统剪切版服务"><a href="#Hook系统剪切版服务" class="headerlink" title="Hook系统剪切版服务"></a>Hook系统剪切版服务</h2><h3 id="伪造剪切版服务对象"><a href="#伪造剪切版服务对象" class="headerlink" title="伪造剪切版服务对象"></a>伪造剪切版服务对象</h3><p>首先我们用代理的方式伪造一个剪切版服务对象，关于如何使用代理的方式进行hook以及其中的原理，可以查看<a href="Hook机制之代理Hook.md">插件框架原理解析——Hook机制之动态代理</a>。</p><p>具体代码如下，我们用动态代理的方式Hook掉了<code>hasPrimaryClip()</code>，<code>getPrimaryClip()</code>这两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderHookHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BinderHookHandler"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原始的Service对象 (IInterface)</span></span><br><span class="line">    Object base;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinderHookHandler</span><span class="params">(IBinder base, Class&lt;?&gt; stubClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method asInterfaceMethod = stubClass.getDeclaredMethod(<span class="string">"asInterface"</span>, IBinder.class);</span><br><span class="line">            <span class="comment">// IClipboard.Stub.asInterface(base);</span></span><br><span class="line">            <span class="keyword">this</span>.base = asInterfaceMethod.invoke(<span class="keyword">null</span>, base);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"hooked failed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TargetApi</span>(Build.VERSION_CODES.HONEYCOMB)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把剪切版的内容替换为 "you are hooked"</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"getPrimaryClip"</span>.equals(method.getName())) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"hook getPrimaryClip"</span>);</span><br><span class="line">            <span class="keyword">return</span> ClipData.newPlainText(<span class="keyword">null</span>, <span class="string">"you are hooked"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 欺骗系统,使之认为剪切版上一直有内容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"hasPrimaryClip"</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> method.invoke(base, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我们拿到原始的<code>IBinder</code>对象之后，如果我们希望使用被Hook之前的系统服务，并不能直接使用这个<code>IBinder</code>对象，而是需要使用<code>asInterface</code>方法将它转换为<code>IClipboard</code>接口；因为<code>getService</code>方法返回的<code>IBinder</code>实际上是一个<strong>裸Binder代理对象</strong>，它只有与驱动打交道的能力，但是它并不能独立工作，需要人指挥它；<code>asInterface</code>方法返回的<code>IClipboard.Stub.Proxy</code>类的对象通过操纵这个裸<code>BinderProxy</code>对象从而实现了具体的<code>IClipboard</code>接口定义的操作。</p><h3 id="伪造IBinder-对象"><a href="#伪造IBinder-对象" class="headerlink" title="伪造IBinder 对象"></a>伪造<code>IBinder</code> 对象</h3><p>在上一步中，我们已经伪造好了系统服务对象，现在要做的就是想办法让<code>asInterface</code>方法返回我们伪造的对象了；我们伪造一个<code>IBinder</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderProxyHookHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BinderProxyHookHandler"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绝大部分情况下,这是一个BinderProxy对象</span></span><br><span class="line">    <span class="comment">// 只有当Service和我们在同一个进程的时候才是Binder本地对象</span></span><br><span class="line">    <span class="comment">// 这个基本不可能</span></span><br><span class="line">    IBinder base;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; stub;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; iinterface;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinderProxyHookHandler</span><span class="params">(IBinder base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.base = base;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.stub = Class.forName(<span class="string">"android.content.IClipboard$Stub"</span>);</span><br><span class="line">            <span class="keyword">this</span>.iinterface = Class.forName(<span class="string">"android.content.IClipboard"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"queryLocalInterface"</span>.equals(method.getName())) &#123;</span><br><span class="line"></span><br><span class="line">            Log.d(TAG, <span class="string">"hook queryLocalInterface"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里直接返回真正被Hook掉的Service接口</span></span><br><span class="line">            <span class="comment">// 这里的 queryLocalInterface 就不是原本的意思了</span></span><br><span class="line">            <span class="comment">// 我们肯定不会真的返回一个本地接口, 因为我们接管了 asInterface方法的作用</span></span><br><span class="line">            <span class="comment">// 因此必须是一个完整的 asInterface 过的 IInterface对象, 既要处理本地对象,也要处理代理对象</span></span><br><span class="line">            <span class="comment">// 这只是一个Hook点而已, 它原始的含义已经被我们重定义了; 因为我们会永远确保这个方法不返回null</span></span><br><span class="line">            <span class="comment">// 让 IClipboard.Stub.asInterface 永远走到if语句的else分支里面</span></span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(proxy.getClass().getClassLoader(),</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// asInterface 的时候会检测是否是特定类型的接口然后进行强制转换</span></span><br><span class="line">                    <span class="comment">// 因此这里的动态代理生成的类型信息的类型必须是正确的</span></span><br><span class="line">                    <span class="keyword">new</span> Class[] &#123; IBinder.class, IInterface.class, <span class="keyword">this</span>.iinterface &#125;,</span><br><span class="line">                    <span class="keyword">new</span> BinderHookHandler(base, stub));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, <span class="string">"method:"</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> method.invoke(base, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用动态代理的方式伪造了一个跟原始<code>IBinder</code>一模一样的对象，然后在这个伪造的<code>IBinder</code>对象的<code>queryLocalInterface</code>方法里面返回了我们第一步创建的<strong>伪造过的系统服务对象</strong>；注意看注释，详细解释可以看<a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">代码</a></p><h3 id="替换ServiceManager的IBinder对象"><a href="#替换ServiceManager的IBinder对象" class="headerlink" title="替换ServiceManager的IBinder对象"></a>替换ServiceManager的<code>IBinder</code>对象</h3><p>现在就是万事具备，只欠东风了；我们使用反射的方式修改<code>ServiceManager</code>类里面缓存的Binder对象，使得<code>getService</code>方法返回我们伪造的<code>IBinder</code>对象，进而<code>asInterface</code>方法使用伪造<code>IBinder</code>对象的<code>queryLocalInterface</code>方法返回了我们伪造的系统服务对象。代码较简单，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String CLIPBOARD_SERVICE = <span class="string">"clipboard"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这一段的意思实际就是: ServiceManager.getService("clipboard");</span></span><br><span class="line"><span class="comment">// 只不过 ServiceManager这个类是@hide的</span></span><br><span class="line">Class&lt;?&gt; serviceManager = Class.forName(<span class="string">"android.os.ServiceManager"</span>);</span><br><span class="line">Method getService = serviceManager.getDeclaredMethod(<span class="string">"getService"</span>, String.class);</span><br><span class="line"><span class="comment">// ServiceManager里面管理的原始的Clipboard Binder对象</span></span><br><span class="line"><span class="comment">// 一般来说这是一个Binder代理对象</span></span><br><span class="line">IBinder rawBinder = (IBinder) getService.invoke(<span class="keyword">null</span>, CLIPBOARD_SERVICE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook 掉这个Binder代理对象的 queryLocalInterface 方法</span></span><br><span class="line"><span class="comment">// 然后在 queryLocalInterface 返回一个IInterface对象, hook掉我们感兴趣的方法即可.</span></span><br><span class="line">IBinder hookedBinder = (IBinder) Proxy.newProxyInstance(serviceManager.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class&lt;?&gt;[] &#123; IBinder.class &#125;,</span><br><span class="line">        <span class="keyword">new</span> BinderProxyHookHandler(rawBinder));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把这个hook过的Binder代理对象放进ServiceManager的cache里面</span></span><br><span class="line"><span class="comment">// 以后查询的时候 会优先查询缓存里面的Binder, 这样就会使用被我们修改过的Binder了</span></span><br><span class="line">Field cacheField = serviceManager.getDeclaredField(<span class="string">"sCache"</span>);</span><br><span class="line">cacheField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Map&lt;String, IBinder&gt; cache = (Map) cacheField.get(<span class="keyword">null</span>);</span><br><span class="line">cache.put(CLIPBOARD_SERVICE, hookedBinder);</span><br></pre></td></tr></table></figure><p>接下来，在app里面使用剪切版，比如长按进行粘贴之后，剪切版的内容永远都是<code>you are hooked</code>了；这样，我们Hook系统服务的目的宣告完成！详细的代码参见 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">github</a>。</p><p>也许你会问，插件框架会这么hook吗？如果不是那么插件框架hook这些干什么？插件框架当然不会做替换文本这么无聊的事情，DroidPlugin插件框架管理插件使得插件就像是主程序一样，因此插件需要使用主程序的剪切版，插件之间也会共用剪切版；其他的一些系统服务也类似，这样就可以达到插件和宿主程序之间的天衣服缝，水乳交融！另外，<code>ActivityManager</code>以及<code>PackageManager</code>这两个系统服务虽然也可以通过这种方式hook，但是由于它们的重要性和特殊性，DroidPlugin使用了另外一种方式，我们会单独讲解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hook机制之Binder-Hook&quot;&gt;&lt;a href=&quot;#Hook机制之Binder-Hook&quot; class=&quot;headerlink&quot; title=&quot;Hook机制之Binder-Hook&quot;&gt;&lt;/a&gt;Hook机制之Binder-Hook&lt;/h1&gt;&lt;p&gt;Android系统通过Binder机制给应用程序提供了一系列的系统服务，诸如&lt;code&gt;ActivityManagerService&lt;/code&gt;，&lt;code&gt;ClipboardManager&lt;/code&gt;， &lt;code&gt;AudioManager&lt;/code&gt;等；这些广泛存在系统服务给应用程序提供了诸如任务管理，音频，视频等异常强大的功能。&lt;/p&gt;
&lt;p&gt;插件框架作为各个插件的管理者，为了使得插件能够&lt;strong&gt;无缝地&lt;/strong&gt;使用这些系统服务，自然会对这些系统服务做出一定的改造(Hook)，使得插件的开发和使用更加方便，从而大大降低插件的开发和维护成本。比如，Hook住&lt;code&gt;ActivityManagerService&lt;/code&gt;可以让插件无缝地使用&lt;code&gt;startActivity&lt;/code&gt;方法而不是使用特定的方式(比如that语法)来启动插件或者主程序的任意界面。&lt;/p&gt;
&lt;p&gt;我们把这种Hook系统服务的机制称之为Binder Hook，因为本质上这些服务提供者都是存在于系统各个进程的Binder对象。因此，要理解接下来的内容必须了解Android的Binder机制，可以参考我之前的文章&lt;a href=&quot;http://weishu.me/2016/01/12/binder-index-for-newer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Binder学习指南&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android插件化原理解析——Hook机制之AMS&amp;PMS</title>
    <link href="https://zhanqq2010.github.io/2018/01/11/Hook%E6%9C%BA%E5%88%B6%E4%B9%8BAMS&amp;PMS/"/>
    <id>https://zhanqq2010.github.io/2018/01/11/Hook机制之AMS&amp;PMS/</id>
    <published>2018-01-11T04:03:39.497Z</published>
    <updated>2018-01-11T04:05:00.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hook机制之AMS-amp-PMS"><a href="#Hook机制之AMS-amp-PMS" class="headerlink" title="Hook机制之AMS&amp;PMS"></a>Hook机制之AMS&amp;PMS</h1><p>在前面的文章中我们介绍了DroidPlugin的Hook机制，也就是<strong>代理方式</strong>和<strong>Binder Hook</strong>；插件框架通过AOP实现了插件使用和开发的透明性。在讲述DroidPlugin如何实现四大组件的插件化之前，有必要说明一下它对ActivityManagerServiche以及PackageManagerService的Hook方式（以下简称AMS，PMS）。</p><p>ActivityManagerService对于FrameWork层的重要性不言而喻，Android的四大组件无一不与它打交道：</p><ol><li><code>startActivity</code>最终调用了AMS的<code>startActivity</code>系列方法，实现了Activity的启动；Activity的生命周期回调，也在AMS中完成；</li><li><code>startService,bindService</code>最终调用到AMS的startService和bindService方法；</li><li>动态广播的注册和接收在<code>AMS</code>中完成（静态广播在<code>PMS</code>中完成）</li><li><code>getContentResolver</code>最终从<code>AMS</code>的<code>getContentProvider</code>获取到ContentProvider</li></ol><p>而<code>PMS</code>则完成了诸如权限校捡(<code>checkPermission,checkUidPermission</code>)，Apk meta信息获取(<code>getApplicationInfo</code>等)，四大组件信息获取(<code>query</code>系列方法)等重要功能。</p><p>在上文<a href="Hook机制之Binder-Hook.md">Android插件化原理解析——Hook机制之Binder Hook</a>中讲述了DroidPlugin的Binder Hook机制；我们知道<code>AMS</code>和<code>PMS</code>就是以Binder方式提供给应用程序使用的系统服务，理论上我们也可以采用这种方式Hook掉它们。但是由于这两者使用得如此频繁，Framework给他们了一些“特别优待”，这也给了我们相对于Binder Hook更加稳定可靠的hook方式。</p><a id="more"></a><p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>，参考此项目的<code>ams-pms-hook</code>模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/" target="_blank" rel="noopener">索引</a>。</p><h2 id="AMS获取过程"><a href="#AMS获取过程" class="headerlink" title="AMS获取过程"></a>AMS获取过程</h2><p>前文提到Android的四大组件无一不与<code>AMS</code>相关，也许读者还有些许疑惑；这里我就挑一个例子，依据Android源码来说明，一个简单的<code>startActivity</code>是如何调用<code>AMS</code>最终通过IPC到system_server的。</p><p>不论读者是否知道，我们使用<code>startActivity</code>有两种形式：</p><ol><li>直接调用<code>Context</code>类的<code>startActivity</code>方法；这种方式启动的Activity没有Activity栈，因此不能以standard方式启动，必须加上<code>FLAG_ACTIVITY_NEW_TASK</code>这个Flag。</li><li>调用被<code>Activity</code>类重载过的<code>startActivity</code>方法，通常在我们的Activity中直接调用这个方法就是这种形式；</li></ol><h3 id="Context-startActivity"><a href="#Context-startActivity" class="headerlink" title="Context.startActivity"></a>Context.startActivity</h3><p>我们查看<code>Context</code>类的<code>startActivity</code>方法，发现这竟然是一个抽象类；查看<code>Context</code>的类继承关系图如下：</p><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1457322345547.png" width="329"></p><p>我们看到诸如<code>Activity</code>，<code>Service</code>等并没有直接继承<code>Context</code>，而是继承了<code>ContextWrapper</code>；继续查看<code>ContextWrapper</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    mBase.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WTF!! 果然人如其名，只是一个wrapper而已；这个<code>mBase</code>是什么呢？这里我先直接告诉你，它的真正实现是<code>ContextImpl</code>类；至于为什么，有一条思路：<em>mBase是在ContextWrapper构造的时候传递进来的，那么在ContextWrapper构造的时候可以找到答案</em><br>什么时候会构造ContextWrapper呢？它的子类<code>Application</code>，<code>Service</code>等被创建的时候。</p><p>可以在App的主线程<code>AcitivityThread</code>的<code>performLaunchActivit</code>方法里面找到答案；更详细的解析可以参考老罗的<a href="http://blog.csdn.net/luoshengyang/article/details/6689748" target="_blank" rel="noopener"> Android应用程序启动过程源代码分析</a></p><p>好了，我们姑且当作已经知道Context.startActivity最终使用了ContextImpl里面的方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(</span><br><span class="line">                <span class="string">"Calling startActivity() from outside of an Activity "</span></span><br><span class="line">                + <span class="string">" context requires the FLAG_ACTIVITY_NEW_TASK flag."</span></span><br><span class="line">                + <span class="string">" Is this really what you want?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">        getOuterContext(), mMainThread.getApplicationThread(), <span class="keyword">null</span>,</span><br><span class="line">        (Activity)<span class="keyword">null</span>, intent, -<span class="number">1</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码相当简单；我们知道了两件事：</p><ol><li>其一，我们知道了在Service等非Activity的Context里面启动Activity为什么需要添加<code>FLAG_ACTIVITY_NEW_TASK</code>；</li><li>其二，真正的<code>startActivity</code>使用了<code>Instrumentation</code>类的<code>execStartActivity</code>方法；继续跟踪：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ... 省略无关代码</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess();</span><br><span class="line">        <span class="comment">// ----------------look here!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">        <span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里我们发现真正调用的是<code>ActivityManagerNative</code>的<code>startActivity</code>方法；如果你不清楚<code>ActivityManager</code>，<code>ActivityManagerService</code>以及<code>ActivityManagerNative</code>之间的关系；建议先仔细阅读我之前关于Binder的文章 <a href="http://weishu.me/2016/01/12/binder-index-for-newer/" target="_blank" rel="noopener">Binder学习指南</a>。</p><h3 id="Activity-startActivity"><a href="#Activity-startActivity" class="headerlink" title="Activity.startActivity"></a>Activity.startActivity</h3><p>Activity类的<code>startActivity</code>方法相比Context而言直观了很多；这个<code>startActivity</code>通过若干次调用辗转到达<code>startActivityForResult</code>这个方法，在这个方法内部有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Instrumentation.ActivityResult ar =</span><br><span class="line">    mInstrumentation.execStartActivity(</span><br><span class="line">        <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">        intent, requestCode, options);</span><br></pre></td></tr></table></figure><p>可以看到，其实通过Activity和ContextImpl类启动Activity并无本质不同，他们都通过<code>Instrumentation</code>这个辅助类调用到了<code>ActivityManagerNative</code>的方法。</p><h2 id="Hook-AMS"><a href="#Hook-AMS" class="headerlink" title="Hook AMS"></a>Hook AMS</h2><p>OK，我们到现在知道；其实<code>startActivity</code>最终通过<code>ActivityManagerNative</code>这个方法远程调用了<code>AMS</code>的<code>startActivity</code>方法。那么这个<code>ActivityManagerNative</code>是什么呢？</p><p>ActivityManagerNative实际上就是<code>ActivityManagerService</code>这个远程对象的Binder代理对象；每次需要与AMS打交道的时候，需要借助这个代理对象通过驱动进而完成IPC调用。</p><p>我们继续看<code>ActivityManagerNative</code>的<code>getDefault()</code>方法做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gDefault.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gDefault</code>这个静态变量的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IBinder b = ServiceManager.getService(<span class="string">"activity</span></span><br><span class="line"><span class="string">        IActivityManager am = asInterface(</span></span><br><span class="line"><span class="string">        return am;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure><p>由于整个Framework与AMS打交道是如此频繁，framework使用了一个单例把这个<code>AMS</code>的代理对象保存了起来；这样只要需要与<code>AMS</code>进行IPC调用，获取这个单例即可。这是<code>AMS</code>这个系统服务与其他普通服务的不同之处，也是我们不通过Binder Hook的原因——我们只需要简单地Hook掉这个单例即可。</p><p>这里还有一点小麻烦：Android不同版本之间对于如何保存这个单例的代理对象是不同的；Android 2.x系统直接使用了一个简单的静态变量存储，Android 4.x以上抽象出了一个Singleton类；具体的差异可以使用<code>grepcode</code>进行比较：<a href="http://grepcode.com/file_/repository.grepcode.com/java/ext/com.google.android/android/4.0.1_r1/android/app/ActivityManagerNative.java/?v=diff&amp;id2=2.3.3_r1" target="_blank" rel="noopener">差异</a></p><p>我们以4.x以上的代码为例说明如何Hook掉<code>AMS</code>；方法使用的动态代理，如果有不理解的，可以参考之前的系列文章<a href="Hook机制之代理Hook.md">Android插件化原理解析——Hook机制之动态代理</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; activityManagerNativeClass = Class.forName(<span class="string">"android.app.ActivityManagerNative"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 gDefault 这个字段, 想办法替换它</span></span><br><span class="line">Field gDefaultField = activityManagerNativeClass.getDeclaredField(<span class="string">"gDefault"</span>);</span><br><span class="line">gDefaultField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object gDefault = gDefaultField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.x以上的gDefault是一个 android.util.Singleton对象; 我们取出这个单例里面的字段</span></span><br><span class="line">Class&lt;?&gt; singleton = Class.forName(<span class="string">"android.util.Singleton"</span>);</span><br><span class="line">Field mInstanceField = singleton.getDeclaredField(<span class="string">"mInstance"</span>);</span><br><span class="line">mInstanceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActivityManagerNative 的gDefault对象里面原始的 IActivityManager对象</span></span><br><span class="line">Object rawIActivityManager = mInstanceField.get(gDefault);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个这个对象的代理对象, 然后替换这个字段, 让我们的代理对象帮忙干活</span></span><br><span class="line">Class&lt;?&gt; iActivityManagerInterface = Class.forName(<span class="string">"android.app.IActivityManager"</span>);</span><br><span class="line">Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class&lt;?&gt;[] &#123; iActivityManagerInterface &#125;, <span class="keyword">new</span> IActivityManagerHandler(rawIActivityManager));</span><br><span class="line">mInstanceField.set(gDefault, proxy);</span><br></pre></td></tr></table></figure><p>好了，我们hook成功之后启动Activity看看会发生什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D/HookHelper﹕ hey, baby; you are hook!!</span><br><span class="line">D/HookHelper﹕ method:activityResumed called with args:[android.os.BinderProxy@9bc71b2]</span><br><span class="line">D/HookHelper﹕ hey, baby; you are hook!!</span><br><span class="line">D/HookHelper﹕ method:activityIdle called with args:[android.os.BinderProxy@9bc71b2, null, false]</span><br><span class="line">D/HookHelper﹕ hey, baby; you are hook!!</span><br><span class="line">D/HookHelper﹕ method:startActivity called with args:[android.app.ActivityThread$ApplicationThread@17e750c, com.weishu.upf.ams_pms_hook.app, Intent &#123; act=android.intent.action.VIEW dat=http://wwww.baidu.com/... &#125;, null, android.os.BinderProxy@9bc71b2, null, -1, 0, null, null]</span><br><span class="line">D/HookHelper﹕ hey, baby; you are hook!!</span><br><span class="line">D/HookHelper﹕ method:activityPaused called with args:[android.os.BinderProxy@9bc71b2]</span><br></pre></td></tr></table></figure><p>可以看到，简单的几行代码，<code>AMS</code>已经被我们完全劫持了!! 至于劫持了能干什么，自己发挥想象吧~</p><p>DroidPlugin关于<code>AMS</code>的Hook，可以查看<code>IActivityManagerHook</code>这个类，它处理了我上述所说的兼容性问题，其他原理相同。另外，也许有童鞋有疑问了，你用<code>startActivity</code>为例怎么能确保Hook掉这个静态变量之后就能保证所有使用<code>AMS</code>的入口都被Hook了呢？</p><p>答曰：无他，唯手熟尔。</p><p>Android Framewrok层对于四大组件的处理，调用<code>AMS</code>服务的时候，全部都是通过使用这种方式；若有疑问可以自行查看源码。你可以从<code>Context</code>类的startActivity, startService,bindService, registerBroadcastReceiver, getContentResolver 等等入口进行跟踪，最终都会发现它们都会使用ActivityManagerNative的这个<code>AMS</code>代理对象来完成对远程AMS的访问。</p><h2 id="PMS获取过程"><a href="#PMS获取过程" class="headerlink" title="PMS获取过程"></a>PMS获取过程</h2><p><code>PMS</code>的获取也是通过Context完成的，具体就是<code>getPackageManager</code>这个方法；我们姑且当作已经知道了Context的实现在ContextImpl类里面，直奔<code>ContextImpl</code>类的<code>getPackageManager</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IPackageManager pm = ActivityThread.getPackageManager();</span><br><span class="line">    <span class="keyword">if</span> (pm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Doesn't matter if we make more than one instance.</span></span><br><span class="line">        <span class="keyword">return</span> (mPackageManager = <span class="keyword">new</span> ApplicationPackageManager(<span class="keyword">this</span>, pm));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里干了两件事：</p><ol><li>真正的<code>PMS</code>的代理对象在<code>ActivityThread</code>类里面</li><li><code>ContextImpl</code>通过<code>ApplicationPackageManager</code>对它还进行了一层包装</li></ol><p>我们继续查看<code>ActivityThread</code>类的<code>getPackageManager</code>方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line">    IBinder b = ServiceManager.getService(<span class="string">"package"</span>);</span><br><span class="line">    sPackageManager = IPackageManager.Stub.asInterface(b);</span><br><span class="line">    <span class="keyword">return</span> sPackageManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，和<code>AMS</code>一样，<code>PMS</code>的Binder代理对象也是一个全局变量存放在一个静态字段中；我们可以如法炮制，Hook掉PMS。</p><p>现在我们的目的很明切，如果需要Hook <code>PMS</code>有两个地方需要Hook掉：</p><ol><li><code>ActivityThread</code>的静态字段<code>sPackageManager</code></li><li>通过Context类的<code>getPackageManager</code>方法获取到的<code>ApplicationPackageManager</code>对象里面的<code>mPM</code>字段。</li></ol><h2 id="Hook-PMS"><a href="#Hook-PMS" class="headerlink" title="Hook PMS"></a>Hook PMS</h2><p>现在使用代理Hook应该是轻车熟路了吧，通过上面的分析，我们Hook两个地方；代码信手拈来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取全局的ActivityThread对象</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ActivityThread里面原始的 sPackageManager</span></span><br><span class="line">Field sPackageManagerField = activityThreadClass.getDeclaredField(<span class="string">"sPackageManager"</span>);</span><br><span class="line">sPackageManagerField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object sPackageManager = sPackageManagerField.get(currentActivityThread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备好代理对象, 用来替换原始的对象</span></span><br><span class="line">Class&lt;?&gt; iPackageManagerInterface = Class.forName(<span class="string">"android.content.pm.IPackageManager"</span>);</span><br><span class="line">Object proxy = Proxy.newProxyInstance(iPackageManagerInterface.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class&lt;?&gt;[] &#123; iPackageManagerInterface &#125;,</span><br><span class="line">        <span class="keyword">new</span> HookHandler(sPackageManager));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 替换掉ActivityThread里面的 sPackageManager 字段</span></span><br><span class="line">sPackageManagerField.set(currentActivityThread, proxy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 替换 ApplicationPackageManager里面的 mPM对象</span></span><br><span class="line">PackageManager pm = context.getPackageManager();</span><br><span class="line">Field mPmField = pm.getClass().getDeclaredField(<span class="string">"mPM"</span>);</span><br><span class="line">mPmField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">mPmField.set(pm, proxy);</span><br></pre></td></tr></table></figure><p>好了，Hook完毕我们验证以下结论；调用一下<code>PMS</code>的<code>getInstalledApplications</code>方法，打印日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">03-07 15:07:27.187    8306-8306/com.weishu.upf.ams_pms_hook.app D/IActivityManagerHandler﹕ hey, baby; you are hook!!</span><br><span class="line">03-07 15:07:27.187    8306-8306/com.weishu.upf.ams_pms_hook.app D/IActivityManagerHandler﹕ method:getInstalledApplications called with args:[0, 0]</span><br></pre></td></tr></table></figure><p>OK，我们又成功劫持了<code>PackageManager</code>！！DroidPlugin 处理PMS的代码可以在<code>IPackageManagerHook</code>查看。</p><p>在结束讲解PackageManager的Hook之前，我们需要说明一点；那就是<code>Context</code>的实现类里面没有使用静态全局变量来保存<code>PMS</code>的代理对象，而是每拥有一个<code>Context</code>的实例就持有了一个<code>PMS</code>代理对象的引用；所以这里有个很蛋疼的事情，那就是我们如果想要完全Hook住<code>PMS</code>，需要精确控制整个进程内部创建的<code>Context</code>对象；所幸，插件框架中，插件的Activity，Service，ContentProvider，Broadcast等所有使用到Context的地方，都是由框架控制创建的；因此我们要小心翼翼地替换掉所有这些对象持有的<code>PMS</code>代理对象。</p><p>我前面也提到过，<strong>静态变量和单例</strong>都是良好的Hook点，这里很好地反证了这句话：想要Hook掉一个实例变量该是多么麻烦!</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>写到这里，关于DroidPlugin的Hook技术的讲解已经完结了；我相信读者或多或少地认识到，其实Hook并不是一项神秘的技术；一个干净，透明的框架少不了AOP，而AOP也少不了Hook。</p><p>我所讲解的Hook仅仅使用反射和动态代理技术，更加强大的Hook机制可以进行<strong>字节码编织</strong>，比如J2EE广泛使用了cglib和asm进行AOP编程；而Android上现有的插件框架还是加载编译时代码，采用动态生成类的技术理论上也是可行的；之前有一篇文章<a href="https://segmentfault.com/a/1190000004077469" target="_blank" rel="noopener">Android动态加载黑科技 动态创建Activity模式</a>，就讲述了这种方式；现在全球的互联网公司不排除有用这种技术实现插件框架的可能 ；我相信不远的未来，这种技术也会在Android上大放异彩。</p><p>了解完Hook技术之后，接下来的系列文章会讲述DroidPlugin对Android四大组件在插件系统上的处理，插件框架对于这一部分的实现是DroidPlugin的精髓，Hook只不过是工具而已。学习这部分内容需要对于Activity，Service，Broadcast以及ContentProvider的工作机制有一定的了解，因此我也会在必要的时候穿插讲解一些Android Framework的知识；我相信这一定会对读者大有裨益。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hook机制之AMS-amp-PMS&quot;&gt;&lt;a href=&quot;#Hook机制之AMS-amp-PMS&quot; class=&quot;headerlink&quot; title=&quot;Hook机制之AMS&amp;amp;PMS&quot;&gt;&lt;/a&gt;Hook机制之AMS&amp;amp;PMS&lt;/h1&gt;&lt;p&gt;在前面的文章中我们介绍了DroidPlugin的Hook机制，也就是&lt;strong&gt;代理方式&lt;/strong&gt;和&lt;strong&gt;Binder Hook&lt;/strong&gt;；插件框架通过AOP实现了插件使用和开发的透明性。在讲述DroidPlugin如何实现四大组件的插件化之前，有必要说明一下它对ActivityManagerServiche以及PackageManagerService的Hook方式（以下简称AMS，PMS）。&lt;/p&gt;
&lt;p&gt;ActivityManagerService对于FrameWork层的重要性不言而喻，Android的四大组件无一不与它打交道：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;startActivity&lt;/code&gt;最终调用了AMS的&lt;code&gt;startActivity&lt;/code&gt;系列方法，实现了Activity的启动；Activity的生命周期回调，也在AMS中完成；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;startService,bindService&lt;/code&gt;最终调用到AMS的startService和bindService方法；&lt;/li&gt;
&lt;li&gt;动态广播的注册和接收在&lt;code&gt;AMS&lt;/code&gt;中完成（静态广播在&lt;code&gt;PMS&lt;/code&gt;中完成）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getContentResolver&lt;/code&gt;最终从&lt;code&gt;AMS&lt;/code&gt;的&lt;code&gt;getContentProvider&lt;/code&gt;获取到ContentProvider&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而&lt;code&gt;PMS&lt;/code&gt;则完成了诸如权限校捡(&lt;code&gt;checkPermission,checkUidPermission&lt;/code&gt;)，Apk meta信息获取(&lt;code&gt;getApplicationInfo&lt;/code&gt;等)，四大组件信息获取(&lt;code&gt;query&lt;/code&gt;系列方法)等重要功能。&lt;/p&gt;
&lt;p&gt;在上文&lt;a href=&quot;Hook机制之Binder-Hook.md&quot;&gt;Android插件化原理解析——Hook机制之Binder Hook&lt;/a&gt;中讲述了DroidPlugin的Binder Hook机制；我们知道&lt;code&gt;AMS&lt;/code&gt;和&lt;code&gt;PMS&lt;/code&gt;就是以Binder方式提供给应用程序使用的系统服务，理论上我们也可以采用这种方式Hook掉它们。但是由于这两者使用得如此频繁，Framework给他们了一些“特别优待”，这也给了我们相对于Binder Hook更加稳定可靠的hook方式。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android插件化原理解析——ContentProvider插件化</title>
    <link href="https://zhanqq2010.github.io/2018/01/11/ContentProvider%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    <id>https://zhanqq2010.github.io/2018/01/11/ContentProvider插件化/</id>
    <published>2018-01-11T04:03:39.494Z</published>
    <updated>2018-01-11T04:04:33.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ContentProvider插件化"><a href="#ContentProvider插件化" class="headerlink" title="ContentProvider插件化"></a>ContentProvider插件化</h1><p>目前为止我们已经完成了Android四大组件中Activity，Service以及BroadcastReceiver的插件化，这几个组件各不相同，我们根据它们的特点定制了不同的插件化方案；那么对于ContentProvider，它又有什么特点？应该如何实现它的插件化？</p><p>与Activity，BroadcastReceiver等频繁被使用的组件不同，我们接触和使用ContentProvider的机会要少得多；但是，ContentProvider这个组件对于Android系统有着特别重要的作用——作为一种极其方便的<strong>数据共享</strong>的手段，ContentProvider使得广大第三方App能够在壁垒森严的系统中自由呼吸。</p><p>在Android系统中，每一个应用程序都有自己的用户ID，而每一个应用程序所创建的文件的读写权限都是只赋予给自己所属的用户，这就限制了应用程序之间相互读写数据的操作。应用程序之间如果希望能够进行交互，只能采取跨进程通信的方式；Binder机制能够满足一般的IPC需求，但是如果应用程序之间需要共享大量数据，单纯使用Binder是很难办到的——我相信大家对于Binder 1M缓冲区以及TransactionTooLargeException一定不陌生；ContentProvider使用了匿名共享内存(Ashmem)机制完成数据共享，因此它可以很方便地完成大量数据的传输。Android系统的短信，联系人，相册，媒体库等等一系列的基础功能都依赖与ContentProvider，它的重要性可见一斑。</p><p>既然ContentProvider的核心特性是数据共享，那么要实现它的插件化，必须能让插件能够把它的ContentProvider共享给系统——如果不能「<strong>provide content</strong>」那还叫什么ContentProvider？</p><p>但是，如果回想一下Activity等组件的插件化方式，在涉及到「共享」这个问题上，一直没有较好的解决方案：<br><a id="more"></a></p><ol><li>系统中的第三方App无法启动插件中带有特定IntentFilter的Activity，因为系统压根儿感受不到插件中这个真正的Activity的存在。</li><li>插件中的静态注册的广播并不真正是静态的，而是使用动态注册广播模拟实现的；这就导致如果宿主程序进程死亡，这个静态广播不会起作用；这个问题的根本原因在由于BroadcastReceiver的IntentFilter的不可预知性，使得我们没有办法把静态广播真正“共享”给系统。</li><li>我们没有办法在第三方App中启动或者绑定插件中的Service组件；因为插件的Service并不是真正的Service组件，系统能感知到的只是那个代理Service；因此如果插件如果带有远程Service组件，它根本不能给第三方App提供远程服务。</li></ol><p>虽然在插件系统中一派生机勃勃的景象，Activity，Service等插件组件百花齐放，插件与宿主、插件与插件争奇斗艳；但是一旦脱离了插件系统的温室，这一片和谐景象不复存在：插件组件不过是傀儡而已；活着的，只有宿主——整个插件系统就是一座死寂的鬼城，各个插件组件借尸还魂般地依附在宿主身上，了无生机。</p><p>既然希望把插件的ContentProvider共享给整个系统，让第三方的App都能获取到我们插件共享的数据，我们必须解决这个问题；下文将会围绕这个目标展开，完成ContentProvider的插件化，并且顺带给出上述问题的解决方案。阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>，参考此项目的 contentprovider-management 模块。另外，插件框架原理解析系列文章见 <a href="概述.md">索引</a>。</p><h2 id="ContentProvider工作原理"><a href="#ContentProvider工作原理" class="headerlink" title="ContentProvider工作原理"></a>ContentProvider工作原理</h2><p>首先我们还是得分析一下ContentProvider的工作原理，很多插件化的思路，以及一些Hook点的发现都严重依赖于对于系统工作原理的理解；对于ContentProvider的插件化，这一点特别重要。</p><h3 id="铺垫工作"><a href="#铺垫工作" class="headerlink" title="铺垫工作"></a>铺垫工作</h3><p>如同我们通过<code>startActivity</code>来启动Activity一样，与ContentProvider打交道的过程也是从Context类的一个方法开始的，这个方法叫做<code>getContentResolver</code>，使用ContentProvider的典型代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ContentResolver resolver = content.getContentResolver();</span><br><span class="line">resolver.query(Uri.parse(<span class="string">"content://authority/test"</span>), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>直接去ContextImpl类里面查找的<code>getContentResolver</code>实现，发现这个方法返回的类型是android.app.ContextImpl.ApplicationContentResolver，这个类是抽象类android.content.ContentResolver的子类，<code>resolver.query</code>实际上是调用父类ContentResolver的<code>query</code>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">Cursor <span class="title">query</span><span class="params">(<span class="keyword">final</span> @NonNull Uri uri, @Nullable String[] projection,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String selection, @Nullable String[] selectionArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String sortOrder, @Nullable CancellationSignal cancellationSignal)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(uri, <span class="string">"uri"</span>);</span><br><span class="line">    IContentProvider unstableProvider = acquireUnstableProvider(uri);</span><br><span class="line">    <span class="keyword">if</span> (unstableProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    IContentProvider stableProvider = <span class="keyword">null</span>;</span><br><span class="line">    Cursor qCursor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">        ICancellationSignal remoteCancellationSignal = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (cancellationSignal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cancellationSignal.throwIfCanceled();</span><br><span class="line">            remoteCancellationSignal = unstableProvider.createCancellationSignal();</span><br><span class="line">            cancellationSignal.setRemote(remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            qCursor = unstableProvider.query(mPackageName, uri, projection,</span><br><span class="line">                    selection, selectionArgs, sortOrder, remoteCancellationSignal);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">            <span class="comment">// The remote process has died...  but we only hold an unstable</span></span><br><span class="line">            <span class="comment">// reference though, so we might recover!!!  Let's try!!!!</span></span><br><span class="line">            <span class="comment">// This is exciting!!1!!1!!!!1</span></span><br><span class="line">            unstableProviderDied(unstableProvider);</span><br><span class="line">            stableProvider = acquireProvider(uri);</span><br><span class="line">            <span class="keyword">if</span> (stableProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            qCursor = stableProvider.query(mPackageName, uri, projection,</span><br><span class="line">                    selection, selectionArgs, sortOrder, remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里面的那个<code>try..catch</code>语句，<code>query</code>方法首先尝试调用抽象方法acquireUnstableProvider拿到一个IContentProvider对象，并尝试调用这个”unstable”对象的<code>query</code>方法，万一调用失败（抛出DeadObjectExceptopn，熟悉Binder的应该了解这个异常）说明ContentProvider所在的进程已经死亡，这时候会尝试调用<code>acquireProvider</code>这个抽象方法来获取一个可用的IContentProvider（代码里面那个萌萌的注释说明了一切^_^）；由于这两个<code>acquire*</code>都是抽象方法，我们可以直接看子类<code>ApplicationContentResolver</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireUnstableProvider</span><span class="params">(Context c, String auth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMainThread.acquireProvider(c,</span><br><span class="line">            ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">            resolveUserIdFromAuthority(auth), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(Context context, String auth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMainThread.acquireProvider(context,</span><br><span class="line">            ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">            resolveUserIdFromAuthority(auth), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这两个抽象方法最终都通过调用<code>ActivityThread</code>类的<code>acquireProvider</code>获取到IContentProvider，接下来我们看看到底是如何获取到ContentProvider的。</p><h3 id="ContentProvider获取过程"><a href="#ContentProvider获取过程" class="headerlink" title="ContentProvider获取过程"></a>ContentProvider获取过程</h3><p>ActivityThread类的<code>acquireProvider</code>方法如下，我们需要知道的是，方法的最后一个参数<code>stable</code>代表着ContentProvider所在的进程是否存活，如果进程已死，可能需要在必要的时候唤起这个进程；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);</span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IActivityManager.ContentProviderHolder holder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        holder = ActivityManagerNative.getDefault().getContentProvider(</span><br><span class="line">                getApplicationThread(), auth, userId, stable);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">"Failed to find provider info for "</span> + auth);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    holder = installProvider(c, holder, holder.info,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/*noisy*/</span>, holder.noReleaseNeeded, stable);</span><br><span class="line">    <span class="keyword">return</span> holder.provider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法首先通过<code>acquireExistingProvider</code>尝试从本进程中获取ContentProvider，如果获取不到，那么再请求<code>AMS</code>获取对应ContentProvider；想象一下，如果你查询的是自己App内部的ContentProvider组件，干嘛要劳烦AMS呢？不论是从哪里获取到的ContentProvider，获取完毕之后会调用<code>installProvider</code>来安装ContentProvider。</p><p>OK打住，我们思考一下，如果要实现ContentProvider的插件化，我们需要完成一些什么工作？开篇的时候我提到了数据共享，那么具体来说，实现插件的数据共享，需要完成什么？ContentProvider是一个数据共享组件，也就是说它不过是<strong>一个携带数据的载体而已</strong>。为了支持跨进程共享，这个载体是<strong>Binder调用</strong>，为了共享大量数据，使用了匿名共享内存；这么说还是有点抽象，那么想一下，给出一个ContentProvider，你能对它做一些什么操作？如果能让插件支持这些操作，不就支持了插件化么？这就是典型的duck type思想——如果一个东西看起来像ContentProvider，用起来也像ContentProvider，那么它就是ContentProvider。</p><p>ContentProvider主要支持<code>query, insert, update, delete</code>操作，由于这个组件一般工作在别的进程，因此这些调用都是Binder调用。从上面的代码可以看到，这些调用最终都是委托给一个IContentProvider的Binder对象完成的，如果我们Hook掉这个对象，那么对于ContentProvider的所有操作都会被我们拦截掉，这时候我们可以做进一步的操作来完成对于插件ContentProvider组件的支持。要拦截这个过程，我们可以<strong>假装插件的ContentProvider是自己App的ContentProvider</strong>，也就是说，让<code>acquireExistingProvider</code>方法可以直接获取到插件的ContentProvider，这样我们就不需要欺骗AMS就能完成插件化了。当然，你也可以选择Hook掉AMS，让AMS的<code>getContentProvider</code>方法返回被我们处理过的对象，这也是可行的；但是，为什么要舍近求远呢？</p><p>从上文的分析暂时得出结论：我们可以把插件的ContentProvider信息预先放在App进程内部，使得对于ContentProvider执行CURD操作的时候，可以获取到插件的组件，这样或许就可以实现插件化了。具体来说，我们要做的事情就是让<code>ActivityThread</code>的<code>acquireExistingProvider</code>方法能够返回插件的ContentProvider信息，我们看看这个方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireExistingProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        <span class="keyword">final</span> ProviderKey key = <span class="keyword">new</span> ProviderKey(auth, userId);</span><br><span class="line">        <span class="keyword">final</span> ProviderClientRecord pr = mProviderMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (pr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 略。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，App内部自己的ContentProvider信息保存在ActivityThread类的<code>mProviderMap</code>中，这个map的类型是ArrayMap<providerkey, providerclientrecord="">；我们当然可以通过反射修改这个成员变量，直接把插件的ContentProvider信息填进去，但是这个ProviderClientRecord对象如何构造？我们姑且看看系统自己是如果填充这个字段的。在ActivityThread类中搜索一遍，发现调用mProviderMap对象的<code>put</code>方法的之后<code>installProviderAuthoritiesLocked</code>，而这个方法最终被<code>installProvider</code>方法调用。在分析ContentProvider的获取过程中我们已经知道，不论是通过本进程的<code>acquireExistingProvider</code>还是借助AMS的<code>getContentProvider</code>得到ContentProvider，最终都会对这个对象执行<code>installProvider</code>操作，也就是「安装」在本进程内部。那么，我们接着看这个<code>installProvider</code>做了什么，它是如何「安装」ContentProvider的。</providerkey,></p><h3 id="进程内部ContentProvider安装过程"><a href="#进程内部ContentProvider安装过程" class="headerlink" title="进程内部ContentProvider安装过程"></a>进程内部ContentProvider安装过程</h3><p>首先，如果之前没有“安装”过，那么holder为null，下面的代码会被执行，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> java.lang.ClassLoader cl = c.getClassLoader();</span><br><span class="line">localProvider = (ContentProvider)cl.</span><br><span class="line">    loadClass(info.name).newInstance();</span><br><span class="line">provider = localProvider.getIContentProvider();</span><br><span class="line"><span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Slog.e(TAG, <span class="string">"Failed to instantiate class "</span> +</span><br><span class="line">          info.name + <span class="string">" from sourceDir "</span> +</span><br><span class="line">          info.applicationInfo.sourceDir);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (DEBUG_PROVIDER) Slog.v(</span><br><span class="line">    TAG, <span class="string">"Instantiating local provider "</span> + info.name);</span><br><span class="line"><span class="comment">// XXX Need to create the correct context for this provider.</span></span><br><span class="line">localProvider.attachInfo(c, info);</span><br></pre></td></tr></table></figure><p>比较直观，直接load这个ContentProvider所在的类，然后用反射创建出这个ContentProvider对象；但是由于查询是需要进行跨进程通信的，在本进程创建出这个对象意义不大，所以我们需要取出ContentProvider承载跨进程通信的Binder对象IContentProvider；创建出对象之后，接下来就是构建合适的信息，保存在ActivityThread内部，也就是<code>mProviderMap</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (localProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ComponentName cname = <span class="keyword">new</span> ComponentName(info.packageName, info.name);</span><br><span class="line">    ProviderClientRecord pr = mLocalProvidersByName.get(cname);</span><br><span class="line">    <span class="keyword">if</span> (pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">            Slog.v(TAG, <span class="string">"installProvider: lost the race, "</span></span><br><span class="line">                    + <span class="string">"using existing local provider"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        provider = pr.mProvider;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        holder = <span class="keyword">new</span> IActivityManager.ContentProviderHolder(info);</span><br><span class="line">        holder.provider = provider;</span><br><span class="line">        holder.noReleaseNeeded = <span class="keyword">true</span>;</span><br><span class="line">        pr = installProviderAuthoritiesLocked(provider, localProvider, holder);</span><br><span class="line">        mLocalProviders.put(jBinder, pr);</span><br><span class="line">        mLocalProvidersByName.put(cname, pr);</span><br><span class="line">    &#125;</span><br><span class="line">    retHolder = pr.mHolder;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure><p>以上就是安装代码，不难理解。</p><h3 id="思路尝试——本地安装"><a href="#思路尝试——本地安装" class="headerlink" title="思路尝试——本地安装"></a>思路尝试——本地安装</h3><p>那么，了解了「安装」过程再结合上文的分析，我们似乎可以完成ContentProvider的插件化了——直接把插件的ContentProvider安装在进程内部就行了。如果插件系统有多个进程，那么必须在每个进程都「安装」一遍，如果你熟悉Android进程的启动流程那么就会知道，这个安装ContentProvider的过程适合放在Application类中，因为每个Android进程启动的时候，App的Application类是会被启动的。</p><p>看起来实现ContentProvider的思路有了，但是这里实际上有一个严重的缺陷！</p><p>我们依然没有解决「共享」的问题。我们只是在插件系统启动的进程里面的ActivityThread的<code>mProviderMap</code>给修改了，这使得只有通过插件系统启动的进程，才能感知到插件中的ContentProvider(因为我们手动把插件中的信息install到这个进程中去了)；如果第三方的App想要使用插件的ContentProvider，那系统只会告诉它查无此人。</p><p>那么，我们应该如何解决共享这个问题呢？看来还是逃不过AMS的魔掌，我们继续跟踪源码，看看如果在本进程查询不到ContentProvider，AMS是如何完成这个过程的。在ActivityThread的<code>acquireProvider</code>方法中我们提到，如果<code>acquireExistingProvider</code>方法返回null，会调用ActivityManagerNative的<code>getContentProvider</code>方法通过AMS查询整个系统中是否存在需要的这个ContentProvider。如果第三方App查询插件系统的ContentProvider必然走的是这个流程，我们仔细分析一下这个过程；</p><h3 id="AMS中的ContentProvider"><a href="#AMS中的ContentProvider" class="headerlink" title="AMS中的ContentProvider"></a>AMS中的ContentProvider</h3><p>首先我们查阅ActivityManagerService的<code>getContentProvider</code>方法，这个方法间接调用了<code>getContentProviderImpl</code>方法；<code>getContentProviderImpl</code>方法体相当的长，但是实际上只做了两件事件事（我这就不贴代码了，读者可以对着源码看一遍）：</p><ol><li>使用PackageManagerService的resolveContentProvider根据Uri中提供的auth信息查阅对应的ContentProivoder的信息ProviderInfo。</li><li>根据查询到的ContentProvider信息，尝试将这个ContentProvider组件安装到系统上。</li></ol><h4 id="查询ContentProvider组件的过程"><a href="#查询ContentProvider组件的过程" class="headerlink" title="查询ContentProvider组件的过程"></a>查询ContentProvider组件的过程</h4><p>查询ContentProvider组件的过程看起来很简单，直接调用PackageManager的<code>resolveContentProvider</code>就能从URI中获取到对应的<code>ProviderInfo</code>信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProviderInfo <span class="title">resolveContentProvider</span><span class="params">(String name, <span class="keyword">int</span> flags, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sUserManager.exists(userId)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// reader</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        <span class="keyword">final</span> PackageParser.Provider provider = mProvidersByAuthority.get(name);</span><br><span class="line">        PackageSetting ps = provider != <span class="keyword">null</span></span><br><span class="line">                ? mSettings.mPackages.get(provider.owner.packageName)</span><br><span class="line">                : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> ps != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mSettings.isEnabledLPr(provider.info, flags, userId)</span><br><span class="line">                &amp;&amp; (!mSafeMode || (provider.info.applicationInfo.flags</span><br><span class="line">                        &amp;ApplicationInfo.FLAG_SYSTEM) != <span class="number">0</span>)</span><br><span class="line">                ? PackageParser.generateProviderInfo(provider, flags,</span><br><span class="line">                        ps.readUserState(userId), userId)</span><br><span class="line">                : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是实际上我们关心的是，这个<code>mProvidersByAuthority</code>里面的信息是如何添加进PackageManagerService的，会在什么时候更新？在PackageManagerService这个类中搜索mProvidersByAuthority.put这个调用，会发现在<code>scanPackageDirtyLI</code>会更新<code>mProvidersByAuthority</code>这个map的信息，接着往前追踪会发现：<strong>这些信息是在Android系统启动的时候收集的</strong>。也就是说，Android系统在启动的时候会扫描一些App的安装目录，典型的比如/data/app/*，获取这个目录里面的apk文件，读取其AndroidManifest.xml中的信息，然后把这些信息保存在PackageManagerService中。合理猜测，在系统启动之后，安装新的App也会触发对新App中AndroidManifest.xml的操作，感兴趣的读者可以自行翻阅源码。</p><p>现在我们知道，查询ContentProvider的信息来源在Android系统启动的时候已经初始化好了，这个过程对于我们第三方app来说是鞭长莫及，想要使用类似在进程内部Hack ContentProvider的查找过程是不可能的。</p><h4 id="安装ContentProvider组件的过程"><a href="#安装ContentProvider组件的过程" class="headerlink" title="安装ContentProvider组件的过程"></a>安装ContentProvider组件的过程</h4><p>获取到URI对应的ContentProvider的信息之后，接下来就是把它安装到系统上了，这样以后有别的查询操作就可以直接拿来使用；但是这个安装过程AMS是没有办法以一己之力完成的。想象一下App DemoA 查询App DemoB 的某个ContentProviderAppB，那么这个ContentProviderAppB必然存在于DemoB这个App中，AMS所在的进程(system_server)连这个ContentProviderAppB的类都没有，因此，AMS必须委托DemoB完成它的ContentProviderAppB的安装；这里就分两种情况：其一，DemoB这个App已经在运行了，那么AMS直接通知DemoB安装ContentProviderAppB（如果B已经安装了那就更好了）；其二，DemoB这个app没在运行，那么必须把B进程唤醒，让它干活；这个过程也就是ActivityManagerService的<code>getContentProviderImpl</code>方法所做的，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (proc != <span class="keyword">null</span> &amp;&amp; proc.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proc.pubProviders.containsKey(cpi.name)) &#123;</span><br><span class="line">        proc.pubProviders.put(cpi.name, cpr);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            proc.thread.scheduleInstallProvider(cpi);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    proc = startProcessLocked(cpi.processName,</span><br><span class="line">            cpr.appInfo, <span class="keyword">false</span>, <span class="number">0</span>, <span class="string">"content provider"</span>,</span><br><span class="line">            <span class="keyword">new</span> ComponentName(cpi.applicationInfo.packageName,</span><br><span class="line">                    cpi.name), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (proc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果查询的ContentProvider所在进程处于运行状态，那么AMS会通过这个进程给AMS的ApplicationThread这个Binder对象完成scheduleInstallProvider调用，这个过程比较简单，最终会调用到目标进程的<code>installProvider</code>方法，而这个方法我们在上文已经分析过了。我们看一下如果目标进程没有启动，会发生什么情况。</p><p>如果ContentProvider所在的进程已经死亡，那么会调用startProcessLocked来启动新的进程，<code>startProcessLocked</code>有一系列重载函数，我们一路跟踪，发现最终启动进程的操作交给了<code>Process</code>类的<code>start</code>方法完成，这个方法通过socket与Zygote进程进行通信，通知Zygote进程fork出一个子进程，然后通过反射调用了之前传递过来的一个入口类的main函数，一般来说这个入口类就是ActivityThread，因此子进程fork出来之后会执行ActivityThread类的main函数。</p><p>在我们继续观察子进程ActivityThread的main函数执行之前，我们看看AMS进程这时候会干什么——startProcessLocked之后AMS进程和fork出来的DemoB进程分道扬镳；AMS会继续往下面执行。我们暂时回到AMS的<code>getContentProviderImpl</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wait for the provider to be published...</span></span><br><span class="line"><span class="keyword">synchronized</span> (cpr) &#123;</span><br><span class="line">    <span class="keyword">while</span> (cpr.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cpr.launchingApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.waiting = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cpr.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.waiting = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你没看错，一个死循环就是糊在上面：AMS进程会通过一个死循环等到进程B完成ContentProvider的安装，等待完成之后会把ContentProvider的信息返回给进程A。那么，我们现在的疑惑是，<strong>进程B在启动之后，在哪个时间点会完成ContentProvider的安装呢？</strong></p><p>我们接着看ActivityThread的main函数，顺便寻找我们上面那个问题的答案；这个分析实际上就是Android App的启动过程，更详细的过程可以参阅老罗的文章 <a href="http://blog.csdn.net/luoshengyang/article/details/6689748" target="_blank" rel="noopener">Android应用程序启动过程源代码分析</a>，这里只给出简要调用流程：</p><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201605/1468313182087.png" alt="App启动简要流程"></p><p>最终，DemoB进程启动之后会执行ActivityThread类的handleBindApplication方法，这个方法相当之长，基本完成了App进程启动之后所有必要的操作；这里我们只关心ContentProvider相关的初始化操作，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the app is being launched for full backup or restore, bring it up in</span></span><br><span class="line"><span class="comment">// a restricted environment with the base application class.</span></span><br><span class="line">Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">mInitialApplication = app;</span><br><span class="line"></span><br><span class="line"><span class="comment">// don't bring up providers in restricted mode; they may depend on the</span></span><br><span class="line"><span class="comment">// app's custom Application class</span></span><br><span class="line"><span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">    List&lt;ProviderInfo&gt; providers = data.providers;</span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        installContentProviders(app, providers);</span><br><span class="line">        <span class="comment">// For process that contains content providers, we want to</span></span><br><span class="line">        <span class="comment">// ensure that the JIT is enabled "at some point".</span></span><br><span class="line">        mH.sendEmptyMessageDelayed(H.ENABLE_JIT, <span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do this after providers, since instrumentation tests generally start their</span></span><br><span class="line"><span class="comment">// test thread at this point, and we don't want that racing.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察以上代码，你会发现：<strong>ContentProvider的安装比Application的onCreate回调还要早！！</strong>因此，分析到这里我们已经明白了前面提出的那个问题，<strong>进程启动之后会在Applition类的onCreate 回调之前，在Application对象创建之后完成ContentProvider的安装</strong>。</p><p>然后不要忘了，我们的AMS进程还在那傻傻等待DemoB进程完成ContentProviderAppB的安装呢！在DemoB的Application的onCreate回调之前，DemoB的ContentProviderAppB已经安装好了，因此AMS停止等待，把DemoB安装的结果返回给请求这个ContentProvider的DemoA。我们必须对这个时序保持敏感，有时候就是失之毫厘，差之千里！！</p><p>到这里，有关ContentProvider的调用过程以及简要的工作原理我们已经分析完毕，关于它如何共享数据，如何使用匿名共享内存这部分不是插件化的重点，感兴趣的可以参考 <a href="http://blog.csdn.net/luoshengyang/article/details/6967204" target="_blank" rel="noopener">Android应用程序组件Content Provider在应用程序之间共享数据的原理分析</a>。</p><h2 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h2><p>在实现ContentProvider的插件化之前，通过分析这个组件的工作原理，我们可以得出它的一些与众不同的特性：</p><ol><li>ContentProvider本身是用来共享数据的，因此它提供一般的CURD服务；它类似HTTP这种无状态的服务，没有Activity，Service所谓的生命周期的概念，服务要么可用，要么不可用；对应着ContentProvider要么启动，要么随着进程死亡；而通常情况下，死亡之后还会被系统启动。所以，ContentProvider，只要有人需要这个服务，系统可以保证是永生的；这是与其他组件的最大不同；完全不用考虑生命周期的概念。</li><li>ContentProvider被设计为共享数据，这种数据量一般来说是相当大的；熟悉Binder的人应该知道，Binder进行数据传输有1M限制，因此如果要使用Binder传输大数据，必须使用类似socket的方式一段一段的读，也就是说需要自己在上层架设一层协议；ContentProvider并没有采取这种方式，而是采用了Android系统的匿名共享内存机制，利用Binder来传输这个文件描述符，进而实现文件的共享；这是第二个不同，因为其他的三个组建通信都是基于Binder的，只有ContentProvider使用了Ashmem。</li><li>一个App启动过程中，ContentProvider组件的启动是非常早的，甚至比Application的onCreate还要早；我们可以利用这个特性结合它不死的特点，完成一些有意义的事情。</li><li>ContentProvider存在优先查询本进程的特点，使得它的插件化甚至不需要Hook AMS就能完成。</li></ol><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>在分析ContentProvider的工作原理的过程中我们提出了一种插件化方案：在进程启动之初，手动把ContentProvider安装到本进程，使得后续对于插件ContentProvider的请求能够顺利完成。我们也指出它的一个严重缺陷，那就是它只能在插件系统内部掩耳盗铃，在插件系统之外，第三方App依然无法感知到插件中的ContentProvider的存在。</p><p>如果插件的ContentProvider组件仅仅是为了共享给其他插件或者宿主程序使用，那么这种方案可以解决问题；不需要Hook AMS，非常简单。</p><p>但是，如果希望把插件ContenProvider共享给整个系统呢？在分析AMS中获取ContentProvider的过程中我们了解到，ContentProvider信息的注册是在Android系统启动或者新安装App的时候完成的，而AMS把ContentProvider返回给第三方App也是在system_server进程完成；我们无法对其暗箱操作。</p><p>在完成Activity，Service组件的插件化之后，这种限制对我们来说已经是小case了：我们在宿主程序里面注册一个货真价实、被系统认可的StubContentProvider组件，把这个组件共享给第三方App；然后通过<strong>代理分发技术</strong>把第三方App对于插件ContentProvider的请求通过这个StubContentProvider分发给对应的插件。</p><p>但是这还存在一个问题，由于第三方App查阅的其实是StubContentProvider，因此他们查阅的URI也必然是StubContentProvider的authority，要查询到插件的ContentProvider，必须把要查询的真正的插件ContentProvider信息传递进来。这个问题的解决方案也很容易，我们可以制定一个「插件查询协议」来实现。</p><p>举个例子，假设插件系统的宿主程序在AndroidManifest.xml中注册了一个StubContentProvider，它的Authority为<code>com.test.host_authority</code>；由于这个组件被注册在AndroidManifest.xml中，是系统认可的ContentProvider组件，整个系统都是可以使用这个共享组件的，使用它的URI一般为<code>content://com.test.host_authority</code>；那么，如果插件系统中存在一个插件，这个插件提供了一个PluginContentProvider，它的Authority为<code>com.test.plugin_authorith</code>，因为这个插件的PluginContentProvider没有在宿主程序的AndroidMainifest.xml中注册（预先注册就失去插件的意义了），整个系统是无法感知到它的存在的；前面提到代理分发技术，也就是，我们让第三方App请求宿主程序的StubContentProvider，这个StubContentProvider把请求转发给合适的插件的ContentProvider就能完成了(插件内部通过预先installProvider可以查询所有的ContentProvider组件)；这个协议可以有很多，比如说：如果第三方App需要请求插件的StubContentProvider，可以以<code>content://com.test.host_authority/com.test.plugin_authorith</code>去查询系统；也就是说，我们假装请求StubContentProvider，把真正的需要请求的PluginContentProvider的Authority放在路径参数里面，StubContentProvider收到这个请求之后，拿到这个真正的Authority去请求插件的PluginContentProvider，拿到结果之后再返回给第三方App。</p><p>这样，我们通过「代理分发技术」以及「插件查询协议」可以完美解决「共享」的问题，开篇提到了我们之前对于Activity，Service组件插件化方案中对于「共享」功能的缺失，按照这个思路，基本可以解决这一系列问题。比如，对于第三方App无法绑定插件服务的问题，我们可以注册一个StubService，把真正需要bind的插件服务信息放在intent的某个字段中，然后在StubService的onBind中解析出这个插件服务信息，然后去拿到插件Service组件的Binder对象返回给第三方。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>上文详细分析了如何实现ContentProvider的插件化，接下来我们就实现这个过程。</p><h3 id="预先installProvider"><a href="#预先installProvider" class="headerlink" title="预先installProvider"></a>预先installProvider</h3><p>要实现预先installProvider，我们首先需要知道，所谓的「预先」到底是在什么时候？</p><p>前文我们提到过App进程安装ContentProvider的时机非常之早，在Application类的onCreate回调执行之前已经完成了；这意味着什么？</p><p>现在我们对于ContentProvider插件化的实现方式是通过「代理分发技术」，也就是说在请求插件ContentProvider的时候会先请求宿主程序的StubContentProvider；如果一个第三方App查询插件的ContentProvider，而宿主程序没有启动的话，AMS会启动宿主程序并等待宿主程序的StubContentProvider完成安装，<strong>一旦安装完成就会把得到的IContentProvider返回给这个第三方App</strong>；第三方App拿到IContentProvider这个Binder对象之后就可能发起CURD操作，如果这个时候插件ContentProvider还没有启动，那么肯定就会出异常；要记住，“这个时候”可能宿主程序的onCreate还没有执行完毕呢！！</p><p>所以，我们基本可以得出结论，预先安装这个所谓的「预先」必须早于Application的onCreate方法，在Android SDK给我们的回调里面，attachBaseContent这个方法是可以满足要求的，它在Application这个对象被创建之后就会立即调用。</p><p>解决了时机问题，那么我们接下来就可以安装ContentProvider了。</p><p>安装ContentProvider也就是要调用ActivityThread类的<code>installProvider</code>方法，这个方法需要的参数有点多，而且它的第二个参数IActivityManager.ContentProviderHolder是一个隐藏类，我们不知道如何构造，就算通过反射构造由于SDK没有暴露稳定性不易保证，我们看看有什么方法调用了这个installProvider。</p><p>installContentProviders这个方法直接调用installProvder看起来可以使用，但是它是一个private的方法，还有public的方法吗？继续往上寻找调用链，发现了installSystemProviders这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">installSystemProviders</span><span class="params">(List&lt;ProviderInfo&gt; providers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        installContentProviders(mInitialApplication, providers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，我们说过ContentProvider的安装必须相当早，必须在Application类的attachBaseContent方法内，而这个<code>mInitialApplication</code>字段是在<code>onCreate</code>方法调用之后初始化的，所以，如果直接使用这个<code>installSystemProviders</code>势必抛出空指针异常；因此，我们只有退而求其次，选择<strong>通过installContentProviders这个方法完成ContentProvider的安装</strong></p><p>要调用这个方法必须拿到ContentProvider对应的ProviderInfo，这个我们在之前也介绍过，可以通过PackageParser类完成，当然这个类有一些兼容性问题，我们需要手动处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析Apk文件中的 &lt;provider&gt;, 并存储起来</span></span><br><span class="line"><span class="comment"> * 主要是调用PackageParser类的generateProviderInfo方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> apkFile 插件对应的apk文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception 解析出错或者反射调用出错, 均会抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;ProviderInfo&gt; <span class="title">parseProviders</span><span class="params">(File apkFile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;?&gt; packageParserClass = Class.forName(<span class="string">"android.content.pm.PackageParser"</span>);</span><br><span class="line">    Method parsePackageMethod = packageParserClass.getDeclaredMethod(<span class="string">"parsePackage"</span>, File.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">    Object packageParser = packageParserClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先调用parsePackage获取到apk对象对应的Package对象</span></span><br><span class="line">    Object packageObj = parsePackageMethod.invoke(packageParser, apkFile, PackageManager.GET_PROVIDERS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取Package对象里面的services字段</span></span><br><span class="line">    <span class="comment">// 接下来要做的就是根据这个List&lt;Provider&gt; 获取到Provider对应的ProviderInfo</span></span><br><span class="line">    Field providersField = packageObj.getClass().getDeclaredField(<span class="string">"providers"</span>);</span><br><span class="line">    List providers = (List) providersField.get(packageObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用generateProviderInfo 方法, 把PackageParser.Provider转换成ProviderInfo</span></span><br><span class="line">    Class&lt;?&gt; packageParser$ProviderClass = Class.forName(<span class="string">"android.content.pm.PackageParser$Provider"</span>);</span><br><span class="line">    Class&lt;?&gt; packageUserStateClass = Class.forName(<span class="string">"android.content.pm.PackageUserState"</span>);</span><br><span class="line">    Class&lt;?&gt; userHandler = Class.forName(<span class="string">"android.os.UserHandle"</span>);</span><br><span class="line">    Method getCallingUserIdMethod = userHandler.getDeclaredMethod(<span class="string">"getCallingUserId"</span>);</span><br><span class="line">    <span class="keyword">int</span> userId = (Integer) getCallingUserIdMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line">    Object defaultUserState = packageUserStateClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要调用 android.content.pm.PackageParser#generateProviderInfo</span></span><br><span class="line">    Method generateProviderInfo = packageParserClass.getDeclaredMethod(<span class="string">"generateProviderInfo"</span>,</span><br><span class="line">            packageParser$ProviderClass, <span class="keyword">int</span>.class, packageUserStateClass, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">    List&lt;ProviderInfo&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 解析出intent对应的Provider组件</span></span><br><span class="line">    <span class="keyword">for</span> (Object service : providers) &#123;</span><br><span class="line">        ProviderInfo info = (ProviderInfo) generateProviderInfo.invoke(packageParser, service, <span class="number">0</span>, defaultUserState, userId);</span><br><span class="line">        ret.add(info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析出ProviderInfo之后，就可以直接调用installContentProvider了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在进程内部安装provider, 也就是调用 ActivityThread.installContentProviders方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context you know</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> apkFile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installProviders</span><span class="params">(Context context, File apkFile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;ProviderInfo&gt; providerInfos = parseProviders(apkFile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ProviderInfo providerInfo : providerInfos) &#123;</span><br><span class="line">        providerInfo.applicationInfo.packageName = context.getPackageName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log.d(<span class="string">"test"</span>, providerInfos.toString());</span><br><span class="line">    Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">    Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">    Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line">    Method installProvidersMethod = activityThreadClass.getDeclaredMethod(<span class="string">"installContentProviders"</span>, Context.class, List.class);</span><br><span class="line">    installProvidersMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    installProvidersMethod.invoke(currentActivityThread, context, providerInfos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个安装过程<strong>必须在Application类的attachBaseContent里面完成</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一定需要Application，并且在attachBaseContext里面Hook</span></span><br><span class="line"><span class="comment"> * 因为provider的初始化非常早，比Application的onCreate还要早</span></span><br><span class="line"><span class="comment"> * 在别的地方hook都晚了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weishu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 16/3/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UPFApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File apkFile = getFileStreamPath(<span class="string">"testcontentprovider-debug.apk"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!apkFile.exists()) &#123;</span><br><span class="line">                Utils.extractAssets(base, <span class="string">"testcontentprovider-debug.apk"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            File odexFile = getFileStreamPath(<span class="string">"test.odex"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hook ClassLoader, 让插件中的类能够被成功加载</span></span><br><span class="line">            BaseDexClassLoaderHookHelper.patchClassLoader(getClassLoader(), apkFile, odexFile);</span><br><span class="line">            ProviderHelper.installProviders(base, getFileStreamPath(<span class="string">"testcontentprovider-debug.apk"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"hook failed"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理分发以及协议解析"><a href="#代理分发以及协议解析" class="headerlink" title="代理分发以及协议解析"></a>代理分发以及协议解析</h3><p>把插件中的ContentProvider安装到插件系统中之后，在插件内部就可以自由使用这些ContentProvider了；要把这些插件共享给整个系统，我们还需要一个货真价实的ContentProvider组件来执行分发：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.example.weishu.contentprovider_management.StubContentProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"com.example.weishu.contentprovider_management.StubContentProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">":p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>第三方App如果要查询到插件的ContentProvider，必须遵循一个「插件查询协议」，这样StubContentProvider才能把对于插件的请求分发到正确的插件组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为了使得插件的ContentProvder提供给外部使用，我们需要一个StubProvider做中转；</span></span><br><span class="line"><span class="comment"> * 如果外部程序需要使用插件系统中插件的ContentProvider，不能直接查询原来的那个uri</span></span><br><span class="line"><span class="comment"> * 我们对uri做一些手脚，使得插件系统能识别这个uri；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这里的处理方式如下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 原始查询插件的URI应该为：</span></span><br><span class="line"><span class="comment"> * content://plugin_auth/path/query</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果需要查询插件，需要修改为：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * content://stub_auth/plugin_auth/path/query</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 也就是，我们把插件ContentProvider的信息放在URI的path中保存起来；</span></span><br><span class="line"><span class="comment"> * 然后在StubProvider中做分发。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当然，也可以使用QueryParamerter,比如：</span></span><br><span class="line"><span class="comment"> * content://plugin_auth/path/query/ -&gt;  content://stub_auth/path/query?plugin=plugin_auth</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> raw 外部查询我们使用的URI</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 插件真正的URI</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Uri <span class="title">getRealUri</span><span class="params">(Uri raw)</span> </span>&#123;</span><br><span class="line">    String rawAuth = raw.getAuthority();</span><br><span class="line">    <span class="keyword">if</span> (!AUTHORITY.equals(rawAuth)) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"rawAuth:"</span> + rawAuth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String uriString = raw.toString();</span><br><span class="line">    uriString = uriString.replaceAll(rawAuth + <span class="string">'/'</span>, <span class="string">""</span>);</span><br><span class="line">    Uri newUri = Uri.parse(uriString);</span><br><span class="line">    Log.i(TAG, <span class="string">"realUri:"</span> + newUri);</span><br><span class="line">    <span class="keyword">return</span> newUri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上过程我们就实现了ContentProvider的插件化。需要说明的是，DroidPlugind的插件化与上述介绍的方案有一些不同之处：</p><ol><li>首先DroidPlugin并没有选择预先安装的方案，而是选择Hook ActivityManagerNative，拦截它的getContentProvider以及publishContentProvider方法实现对于插件组件的控制；从这里可以看出它对ContentProvider与Service的插件化几乎是相同的，Hook才是DroidPlugin Style ^_^.</li><li>然后，关于携带插件信息，或者说「插件查询协议」方面；DroidPlugin把插件信息放在查询参数里面，本文呢则是路径参数；这一点完全看个人喜好。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们通过「代理分发技术」以及「插件查询协议」完成了ContentProvider组件的插件化，并且给出了对「插件共享组件」的问题的一般解决方案。值得一提的是，系统的ContentProvider其实是lazy load的，也就是说只有在需要使用的时候才会启动对应的ContentProvider，而我们对于插件的实现则是<strong>预先加载</strong>，这里还有改进的空间，读者可以思考一下解决方案。</p><p>由于ContentProvider的使用频度非常低，而很多它使用的场景（比如系统）并不太需要「插件化」，因此在实际的插件方案中，提供ContentProvider插件化的方案非常之少；就算需要实现ContentProvider的插件化，也只是解决插件内部之间共享组件的问题，并没有把插件组件暴露给整个系统。我个人觉得，如果只是希望插件化，那么是否支持ContentProvider无伤大雅，但是，如果希望实现虚拟化或者说容器技术，所有组件是必须支持插件化的。</p><p>至此，对于Android系统的四大组件的插件化已经全部介绍完毕；由于是最后一个要介绍的组件，我并没有像之前一样先给出组件的运行原理，然后一通分析最后给出插件方案，而是一边分析代码一边给出自己的思路，把思考——推翻——改进的整个过程完全展现了出来，Android的插件化已经到达了百花齐放的阶段，插件化之路也不只有一条，但是万变不离其宗，希望我的分析和思考对各位读者理解甚至创造插件化方案带来帮助。接下来我会介绍「插件通信机制」，它与本文的ContentProvider以及我反复强调过的一些特性密切相关，敬请期待！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ContentProvider插件化&quot;&gt;&lt;a href=&quot;#ContentProvider插件化&quot; class=&quot;headerlink&quot; title=&quot;ContentProvider插件化&quot;&gt;&lt;/a&gt;ContentProvider插件化&lt;/h1&gt;&lt;p&gt;目前为止我们已经完成了Android四大组件中Activity，Service以及BroadcastReceiver的插件化，这几个组件各不相同，我们根据它们的特点定制了不同的插件化方案；那么对于ContentProvider，它又有什么特点？应该如何实现它的插件化？&lt;/p&gt;
&lt;p&gt;与Activity，BroadcastReceiver等频繁被使用的组件不同，我们接触和使用ContentProvider的机会要少得多；但是，ContentProvider这个组件对于Android系统有着特别重要的作用——作为一种极其方便的&lt;strong&gt;数据共享&lt;/strong&gt;的手段，ContentProvider使得广大第三方App能够在壁垒森严的系统中自由呼吸。&lt;/p&gt;
&lt;p&gt;在Android系统中，每一个应用程序都有自己的用户ID，而每一个应用程序所创建的文件的读写权限都是只赋予给自己所属的用户，这就限制了应用程序之间相互读写数据的操作。应用程序之间如果希望能够进行交互，只能采取跨进程通信的方式；Binder机制能够满足一般的IPC需求，但是如果应用程序之间需要共享大量数据，单纯使用Binder是很难办到的——我相信大家对于Binder 1M缓冲区以及TransactionTooLargeException一定不陌生；ContentProvider使用了匿名共享内存(Ashmem)机制完成数据共享，因此它可以很方便地完成大量数据的传输。Android系统的短信，联系人，相册，媒体库等等一系列的基础功能都依赖与ContentProvider，它的重要性可见一斑。&lt;/p&gt;
&lt;p&gt;既然ContentProvider的核心特性是数据共享，那么要实现它的插件化，必须能让插件能够把它的ContentProvider共享给系统——如果不能「&lt;strong&gt;provide content&lt;/strong&gt;」那还叫什么ContentProvider？&lt;/p&gt;
&lt;p&gt;但是，如果回想一下Activity等组件的插件化方式，在涉及到「共享」这个问题上，一直没有较好的解决方案：&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android插件化原理解析——插件加载机制</title>
    <link href="https://zhanqq2010.github.io/2018/01/11/ClassLoader%E7%AE%A1%E7%90%86/"/>
    <id>https://zhanqq2010.github.io/2018/01/11/ClassLoader管理/</id>
    <published>2018-01-11T04:03:39.492Z</published>
    <updated>2018-01-11T04:04:42.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插件加载机制"><a href="#插件加载机制" class="headerlink" title="插件加载机制"></a>插件加载机制</h1><p>上文 <a href="Activity生命周期管理.md">Activity生命周期管理</a> 中我们地完成了『启动没有在AndroidManifest.xml中显式声明的Activity』的任务；通过Hook <code>AMS</code>和拦截ActivityThread中<code>H</code>类对于组件调度我们成功地绕过了AndroidMAnifest.xml的限制。</p><p>但是我们启动的『没有在AndroidManifet.xml中显式声明』的Activity和宿主程序存在于同一个Apk中；通常情况下，插件均以独立的文件存在甚至通过网络获取，这时候插件中的Activity能否成功启动呢？</p><p>要启动Activity组件肯定先要创建对应的Activity类的对象，从上文 <a href="Activity生命周期管理.md">Activity生命周期管理</a> 知道，创建Activity类对象的过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">activity = mInstrumentation.newActivity(</span><br><span class="line">        cl, component.getClassName(), r.intent);</span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure><p>也就是说，系统通过<code>ClassLoader</code>加载了需要的Activity类并通过反射调用构造函数创建出了Activity对象。如果Activity组件存在于独立于宿主程序的文件之中，系统的ClassLoader怎么知道去哪里加载呢？因此，如果不做额外的处理，插件中的Activity对象甚至都没有办法创建出来，谈何启动？</p><p>因此，要使存在于独立文件或者网络中的插件被成功启动，首先就需要解决这个<strong>插件类加载</strong>的问题。<br>下文将围绕此问题展开，完成『启动没有在AndroidManifest.xml中显示声明，并且存在于外部插件中的Activity』的任务。</p><p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>，参考此项目的<code>classloader-hook</code> 模块。另外，插件框架原理解析系列文章见<a href="概述.md">索引</a>。</p><a id="more"></a><h2 id="ClassLoader机制"><a href="#ClassLoader机制" class="headerlink" title="ClassLoader机制"></a>ClassLoader机制</h2><p>或许有的童鞋还不太了解Java的ClassLoader机制，我这里简要介绍一下。</p><blockquote><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校检、转换解析和初始化的，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<br>与那些在编译时进行链连接工作的语言不同，在Java语言里面，类型的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以同代拓展的语言特性就是依赖运行期动态加载和动态链接这个特点实现的。例如，如果编写一个面相接口的应用程序，可以等到运行时在制定实际的实现类；用户可以通过Java与定义的和自定义的类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为代码的一部分，这种组装应用程序的方式目前已经广泛应用于Java程序之中。从最基础的Applet，JSP到复杂的OSGi技术，都使用了Java语言运行期类加载的特性。</p></blockquote><p>Java的类加载是一个相对复杂的过程；它包括加载、验证、准备、解析和初始化五个阶段；对于开发者来说，可控性最强的是<strong>加载阶段</strong>；加载阶段主要完成三件事：</p><ol><li>根据一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为JVM方法区中的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>『通过一个类的全限定名获取描述此类的二进制字节流』这个过程被抽象出来，就是Java的类加载器模块，也即JDK中ClassLoader API。</p><p>Android Framework提供了DexClassLoader这个类，简化了『通过一个类的全限定名获取描述次类的二进制字节流』这个过程；我们只需要告诉DexClassLoader一个dex文件或者apk文件的路径就能完成类的加载。因此本文的内容用一句话就可以概括：</p><p><strong>将插件的dex或者apk文件告诉『合适的』DexClassLoader，借助它完成插件类的加载</strong></p><p>关于CLassLoader机制更多的内容，请参阅『深入理解Java虚拟机』这本书。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>Android系统使用了ClassLoader机制来进行Activity等组件的加载；apk被安装之后，APK文件的代码以及资源会被系统存放在固定的目录（比如/data/app/package_name/base-1.apk )系统在进行类加载的时候，会自动去这一个或者几个特定的路径来寻找这个类；但是系统并不知道存在于插件中的Activity组件的信息(插件可以是任意位置，甚至是网络，系统无法提前预知)，因此正常情况下系统无法加载我们插件中的类；因此也没有办法创建Activity的对象，更不用谈启动组件了。</p><p>解决这个问题有两个思路，要么全盘接管这个类加载的过程；要么告知系统我们使用的插件存在于哪里，让系统帮忙加载；这两种方式或多或少都需要<strong>干预</strong>这个类加载的过程。老规矩，知己知彼，百战不殆。我们首先分析一下，系统是如果完成这个类加载过程的。</p><p>我们再次搬出Activity的创建过程的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure><p>这里可以很明显地看到，系统通过待启动的Activity的类名<code>className</code>，然后使用ClassLoader对象<code>cl</code>把这个类加载进虚拟机，最后使用反射创建了这个Activity类的实例对象。要想干预这个ClassLoader（告知它我们的路径或者替换他），我们首先得看看这玩意到底是个什么来头。（从哪里创建的）</p><p><code>cl</code>这个ClasssLoader对象通过<code>r.packageInfo</code>对象的getClassLoader()方法得到，r.packageInfo是一个LoadedApk类的对象；那么，LoadedApk到底是个什么东西？？</p><p>我们查阅LoadedApk类的文档，只有一句话，不过说的很明白：</p><blockquote><p>Local state maintained about a currently loaded .apk.</p></blockquote><p><strong>LoadedApk对象是APK文件在内存中的表示。</strong> Apk文件的相关信息，诸如Apk文件的代码和资源，甚至代码里面的Activity，Service等组件的信息我们都可以通过此对象获取。</p><p>OK, 我们知道这个LoadedApk是何方神圣了；接下来我们要搞清楚的是：这个 <code>r.packageInfo</code> 到底是从哪里获取的？</p><p>我们顺着 performLaunchActivity上溯，辗转handleLaunchActivity回到了 <code>H</code> 类的LAUNCH_ACTIVITY消息，找到了<code>r.packageInfo</code>的来源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line">r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">        r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">handleLaunchActivity(r, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>getPackageInfoNoCheck方法很简单，直接调用了getPackageInfo方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> LoadedApk <span class="title">getPackageInfoNoCheck</span><span class="params">(ApplicationInfo ai,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getPackageInfo(ai, compatInfo, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个getPackageInfo方法里面我们发现了端倪：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LoadedApk <span class="title">getPackageInfo</span><span class="params">(ApplicationInfo aInfo, CompatibilityInfo compatInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassLoader baseLoader, <span class="keyword">boolean</span> securityViolation, <span class="keyword">boolean</span> includeCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> registerPackage)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取userid信息</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> differentUser = (UserHandle.myUserId() != UserHandle.getUserId(aInfo.uid));</span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">    <span class="comment">// 尝试获取缓存信息</span></span><br><span class="line">        WeakReference&lt;LoadedApk&gt; ref;</span><br><span class="line">        <span class="keyword">if</span> (differentUser) &#123;</span><br><span class="line">            <span class="comment">// Caching not supported across users</span></span><br><span class="line">            ref = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (includeCode) &#123;</span><br><span class="line">            ref = mPackages.get(aInfo.packageName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ref = mResourcePackages.get(aInfo.packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LoadedApk packageInfo = ref != <span class="keyword">null</span> ? ref.get() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span> || (packageInfo.mResources != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;</span><br><span class="line">                <span class="comment">// 缓存没有命中，直接new</span></span><br><span class="line">            packageInfo =</span><br><span class="line">                <span class="keyword">new</span> LoadedApk(<span class="keyword">this</span>, aInfo, compatInfo, baseLoader,</span><br><span class="line">                        securityViolation, includeCode &amp;&amp;</span><br><span class="line">                        (aInfo.flags&amp;ApplicationInfo.FLAG_HAS_CODE) != <span class="number">0</span>, registerPackage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略。。更新缓存</span></span><br><span class="line">        <span class="keyword">return</span> packageInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法很重要，我们必须弄清楚每一步；</p><p>首先，它判断了调用方和或许App信息的一方是不是同一个userId；如果是同一个user，那么可以共享缓存数据（要么缓存的代码数据，要么缓存的资源数据）</p><p>接下来尝试获取缓存数据；如果没有命中缓存数据，才通过LoadedApk的构造函数创建了LoadedApk对象；创建成功之后，如果是同一个uid还放入了缓存。</p><p>提到缓存数据，看过<a href="Hook机制之Binder-Hook.md">Hook机制之Binder Hook</a>的童鞋可能就知道了，我们之前成功借助ServiceManager的本地代理使用缓存的机制Hook了各种Binder；因此这里完全可以如法炮制——我们拿到这一份缓存数据，修改里面的ClassLoader；自己控制类加载的过程，这样加载插件中的Activity类的问题就解决了。这就引出了我们加载插件类的第一种方案：</p><h2 id="激进方案：Hook掉ClassLoader，自己操刀"><a href="#激进方案：Hook掉ClassLoader，自己操刀" class="headerlink" title="激进方案：Hook掉ClassLoader，自己操刀"></a>激进方案：Hook掉ClassLoader，自己操刀</h2><p>从上述分析中我们得知，在获取LoadedApk的过程中使用了一份缓存数据；这个缓存数据是一个<code>Map</code>，从包名到LoadedApk的一个映射。正常情况下，我们的插件肯定不会存在于这个对象里面；但是<strong>如果我们手动把我们插件的信息添加到里面呢？</strong>系统在查找缓存的过程中，会直接命中缓存！进而使用我们添加进去的LoadedApk的ClassLoader来加载这个特定的Activity类！这样我们就能接管我们自己插件类的加载过程了！</p><!--但是，细心的读者可能会发现；缓存命中还有一个条件——UID相同，因此我们需要**共享UID**--><p>这个缓存对象<code>mPackages</code>存在于ActivityThread类中；老方法，我们首先获取这个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取到当前的ActivityThread对象</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到 mPackages 这个静态成员变量, 这里缓存了dex包的信息</span></span><br><span class="line">Field mPackagesField = activityThreadClass.getDeclaredField(<span class="string">"mPackages"</span>);</span><br><span class="line">mPackagesField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Map mPackages = (Map) mPackagesField.get(currentActivityThread);</span><br></pre></td></tr></table></figure><p>拿到这个Map之后接下来怎么办呢？<strong>我们需要填充这个map，把插件的信息塞进这个map里面</strong>，以便系统在查找的时候能命中缓存。但是这个填充这个Map我们出了需要包名之外，还需要一个LoadedApk对象；如何创建一个LoadedApk对象呢？</p><p>我们当然可以直接反射调用它的构造函数直接创建出需要的对象，但是万一哪里有疏漏，构造参数填错了怎么办？又或者Android的不同版本使用了不同的参数，导致我们创建出来的对象与系统创建出的对象不一致，无法work怎么办？</p><p>因此我们需要使用与系统完全相同的方式创建LoadedApk对象；从上文分析得知，系统创建LoadedApk对象是通过<code>getPackageInfo</code>来完成的，因此我们可以调用这个函数来创建LoadedApk对象；但是这个函数是<code>private</code>的，我们无法使用。</p><p>有的童鞋可能会有疑问了，<code>private</code>不是也能反射到吗？我们确实能够调用这个函数，但是<code>private</code>表明这个函数是内部实现，或许那一天Google高兴，把这个函数改个名字我们就直接GG了；但是public函数不同，public被导出的函数你无法保证是否有别人调用它，因此大部分情况下不会修改；我们最好调用public函数来保证尽可能少的遇到兼容性问题。（当然，如果实在木有路可以考虑调用私有方法，自己处理兼容性问题，这个我们以后也会遇到）</p><p>间接调用<code>getPackageInfo</code>这个私有函数的public函数有同名的getPackageInfo系列和getPackageInfoNoCheck；简单查看源代码发现，getPackageInfo除了获取包的信息，还检查了包的一些组件；为了绕过这些验证，我们选择使用<code>getPackageInfoNoCheck</code>获取LoadedApk信息。</p><h3 id="构建插件LoadedApk对象"><a href="#构建插件LoadedApk对象" class="headerlink" title="构建插件LoadedApk对象"></a>构建插件LoadedApk对象</h3><p>我们这一步的目的很明确，通过getPackageInfoNoCheck函数创建出我们需要的LoadedApk对象，以供接下来使用。</p><p>这个函数的签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> LoadedApk <span class="title">getPackageInfoNoCheck</span><span class="params">(ApplicationInfo ai,</span></span></span><br><span class="line"><span class="function"><span class="params">            CompatibilityInfo compatInfo)</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>因此，为了调用这个函数，我们需要构造两个参数。其一是ApplicationInfo，其二是CompatibilityInfo；第二个参数顾名思义，代表这个App的兼容性信息，比如targetSDK版本等等，这里我们只需要提取出app的信息，因此直接使用默认的兼容性即可；在CompatibilityInfo类里面有一个公有字段DEFAULT_COMPATIBILITY_INFO代表默认兼容性信息；因此，我们的首要目标是获取这个ApplicationInfo信息。</p><h3 id="构建插件ApplicationInfo信息"><a href="#构建插件ApplicationInfo信息" class="headerlink" title="构建插件ApplicationInfo信息"></a>构建插件ApplicationInfo信息</h3><p>我们首先看看ApplicationInfo代表什么，这个类的文档说的很清楚：</p><blockquote><p>Information you can retrieve about a particular application.  This corresponds to information collected from the AndroidManifest.xml’s &lt;application&gt; tag.</p></blockquote><p>也就是说，这个类就是AndroidManifest.xml里面的<application> 这个标签下面的信息；这个AndroidManifest.xml无疑是一个标准的xml文件，因此我们完全可以自己使用parse来解析这个信息。</application></p><p>那么，系统是如何获取这个信息的呢？其实Framework就有一个这样的parser，也即PackageParser；理论上，我们也可以借用系统的parser来解析AndroidMAnifest.xml从而得到ApplicationInfo的信息。但遗憾的是，<strong>这个类的兼容性很差</strong>；Google几乎在每一个Android版本都对这个类动刀子，如果坚持使用系统的解析方式，必须写一系列兼容行代码！！DroidPlugin就选择了这种方式，相关类如下：</p><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829051777.png" width="283" alt="DroidPlugin的PackageParser"></p><p>看到这里我就问你怕不怕！！！这也是我们之前提到的<strong>私有或者隐藏的API可以使用，但必须处理好兼容性问题</strong>；如果Android 7.0发布，这里估计得添加一个新的类PackageParseApi24。</p><p>我这里使用API 23作为演示，<strong>版本不同的可能无法运行</strong>请自行查阅 DroidPlugin 不同版本如何处理。</p><p>OK回到正题，我们决定使用PackageParser类来提取ApplicationInfo信息。下图是API 23上，PackageParser的部分类结构图：</p><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829674687.png" width="481"></p><p>看起来有我们需要的方法 generateApplication；确实如此，依靠这个方法我们可以成功地拿到ApplicationInfo。<br>由于PackageParser是@hide的，因此我们需要通过反射进行调用。我们根据这个generateApplicationInfo方法的签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationInfo <span class="title">generateApplicationInfo</span><span class="params">(Package p, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">   PackageUserState state)</span></span></span><br></pre></td></tr></table></figure><p>可以写出调用generateApplicationInfo的反射代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; packageParserClass = Class.forName(<span class="string">"android.content.pm.PackageParser"</span>);</span><br><span class="line"><span class="comment">// 首先拿到我们得终极目标: generateApplicationInfo方法</span></span><br><span class="line"><span class="comment">// API 23 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="comment">// public static ApplicationInfo generateApplicationInfo(Package p, int flags,</span></span><br><span class="line"><span class="comment">//    PackageUserState state) &#123;</span></span><br><span class="line"><span class="comment">// 其他Android版本不保证也是如此.</span></span><br><span class="line">Class&lt;?&gt; packageParser$PackageClass = Class.forName(<span class="string">"android.content.pm.PackageParser$Package"</span>);</span><br><span class="line">Class&lt;?&gt; packageUserStateClass = Class.forName(<span class="string">"android.content.pm.PackageUserState"</span>);</span><br><span class="line">Method generateApplicationInfoMethod = packageParserClass.getDeclaredMethod(<span class="string">"generateApplicationInfo"</span>,</span><br><span class="line">        packageParser$PackageClass,</span><br><span class="line">        <span class="keyword">int</span>.class,</span><br><span class="line">                packageUserStateClass);</span><br></pre></td></tr></table></figure><p>要成功调用这个方法，还需要三个参数；因此接下来我们需要一步一步构建调用此函数的参数信息。</p><h4 id="构建PackageParser-Package"><a href="#构建PackageParser-Package" class="headerlink" title="构建PackageParser.Package"></a>构建PackageParser.Package</h4><p>generateApplicationInfo方法需要的第一个参数是PackageParser.Package；从名字上看这个类代表某个apk包的信息，我们看看文档怎么解释：</p><blockquote><p>Representation of a full package parsed from APK files on disk. A package consists of a single base APK, and zero or more split APKs.</p></blockquote><p>果然，这个类代表从PackageParser中解析得到的某个apk包的信息，是磁盘上apk文件在内存中的数据结构表示；因此，要获取这个类，肯定需要解析整个apk文件。PackageParser中解析apk的核心方法是parsePackage，这个方法返回的就是一个Package类型的实例，因此我们调用这个方法即可；使用反射代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先, 我们得创建出一个Package对象出来供这个方法调用</span></span><br><span class="line"><span class="comment">// 而这个需要得对象可以通过 android.content.pm.PackageParser#parsePackage 这个方法返回得 Package对象得字段获取得到</span></span><br><span class="line"><span class="comment">// 创建出一个PackageParser对象供使用</span></span><br><span class="line">Object packageParser = packageParserClass.newInstance();</span><br><span class="line"><span class="comment">// 调用 PackageParser.parsePackage 解析apk的信息</span></span><br><span class="line">Method parsePackageMethod = packageParserClass.getDeclaredMethod(<span class="string">"parsePackage"</span>, File.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上是一个 android.content.pm.PackageParser.Package 对象</span></span><br><span class="line">Object packageObj = parsePackageMethod.invoke(packageParser, apkFile, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这样，我们就得到了generateApplicationInfo的第一个参数；第二个参数是解析包使用的flag，我们直接选择解析全部信息，也就是0；</p><h4 id="构建PackageUserState"><a href="#构建PackageUserState" class="headerlink" title="构建PackageUserState"></a>构建PackageUserState</h4><p>第三个参数是PackageUserState，代表不同用户中包的信息。由于Android是一个多任务多用户系统，因此不同的用户同一个包可能有不同的状态；这里我们只需要获取包的信息，因此直接使用默认的即可；</p><p>至此，generateApplicaionInfo的参数我们已经全部构造完成，直接调用此方法即可得到我们需要的applicationInfo对象；在返回之前我们需要做一点小小的修改：使用系统系统的这个方法解析得到的ApplicationInfo对象中并没有apk文件本身的信息，所以我们把解析的apk文件的路径设置一下（ClassLoader依赖dex文件以及apk的路径）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三个参数 mDefaultPackageUserState 我们直接使用默认构造函数构造一个出来即可</span></span><br><span class="line">Object defaultPackageUserState = packageUserStateClass.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 万事具备!!!!!!!!!!!!!!</span></span><br><span class="line">ApplicationInfo applicationInfo = (ApplicationInfo) generateApplicationInfoMethod.invoke(packageParser,</span><br><span class="line">        packageObj, <span class="number">0</span>, defaultPackageUserState);</span><br><span class="line">String apkPath = apkFile.getPath();</span><br><span class="line">applicationInfo.sourceDir = apkPath;</span><br><span class="line">applicationInfo.publicSourceDir = apkPath;</span><br></pre></td></tr></table></figure><h3 id="替换ClassLoader"><a href="#替换ClassLoader" class="headerlink" title="替换ClassLoader"></a>替换ClassLoader</h3><h4 id="获取LoadedApk信息"><a href="#获取LoadedApk信息" class="headerlink" title="获取LoadedApk信息"></a>获取LoadedApk信息</h4><p>方才为了获取ApplicationInfo我们费了好大一番精力；回顾一下我们的初衷：</p><p>我们最终的目的是调用getPackageInfoNoCheck得到LoadedApk的信息，并替换其中的mClassLoader然后把把添加到ActivityThread的mPackages缓存中；从而达到我们使用自己的ClassLoader加载插件中的类的目的。</p><p>现在我们已经拿到了getPackageInfoNoCheck这个方法中至关重要的第一个参数applicationInfo；上文提到第二个参数CompatibilityInfo代表设备兼容性信息，直接使用默认的值即可；因此，两个参数都已经构造出来，我们可以调用getPackageInfoNoCheck获取LoadedApk：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.content.res.CompatibilityInfo</span></span><br><span class="line">Class&lt;?&gt; compatibilityInfoClass = Class.forName(<span class="string">"android.content.res.CompatibilityInfo"</span>);</span><br><span class="line">Method getPackageInfoNoCheckMethod = activityThreadClass.getDeclaredMethod(<span class="string">"getPackageInfoNoCheck"</span>, ApplicationInfo.class, compatibilityInfoClass);</span><br><span class="line"></span><br><span class="line">Field defaultCompatibilityInfoField = compatibilityInfoClass.getDeclaredField(<span class="string">"DEFAULT_COMPATIBILITY_INFO"</span>);</span><br><span class="line">defaultCompatibilityInfoField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Object defaultCompatibilityInfo = defaultCompatibilityInfoField.get(<span class="keyword">null</span>);</span><br><span class="line">ApplicationInfo applicationInfo = generateApplicationInfo(apkFile);</span><br><span class="line"></span><br><span class="line">Object loadedApk = getPackageInfoNoCheckMethod.invoke(currentActivityThread, applicationInfo, defaultCompatibilityInfo);</span><br></pre></td></tr></table></figure><p>我们成功地构造出了LoadedAPK, 接下来我们需要替换其中的ClassLoader，然后把它添加进ActivityThread的mPackages中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String odexPath = Utils.getPluginOptDexDir(applicationInfo.packageName).getPath();</span><br><span class="line">String libDir = Utils.getPluginLibDir(applicationInfo.packageName).getPath();</span><br><span class="line">ClassLoader classLoader = <span class="keyword">new</span> CustomClassLoader(apkFile.getPath(), odexPath, libDir, ClassLoader.getSystemClassLoader());</span><br><span class="line">Field mClassLoaderField = loadedApk.getClass().getDeclaredField(<span class="string">"mClassLoader"</span>);</span><br><span class="line">mClassLoaderField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">mClassLoaderField.set(loadedApk, classLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于是弱引用, 因此我们必须在某个地方存一份, 不然容易被GC; 那么就前功尽弃了.</span></span><br><span class="line">sLoadedApk.put(applicationInfo.packageName, loadedApk);</span><br><span class="line"></span><br><span class="line">WeakReference weakReference = <span class="keyword">new</span> WeakReference(loadedApk);</span><br><span class="line">mPackages.put(applicationInfo.packageName, weakReference);</span><br></pre></td></tr></table></figure><p>我们的这个CustomClassLoader非常简单，直接继承了DexClassLoader，什么都没有做；当然这里可以直接使用DexClassLoader，这里重新创建一个类是为了更有区分度；以后也可以通过修改这个类实现对于类加载的控制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">DexClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, optimizedDirectory, libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们已经成功地把把插件的信息放入ActivityThread中，这样我们插件中的类能够成功地被加载；因此插件中的Activity实例能被成功第创建；由于整个流程较为复杂，我们简单梳理一下：</p><ol><li>在ActivityThread接收到IApplication的 scheduleLaunchActivity远程调用之后，将消息转发给<code>H</code></li><li><code>H</code>类在handleMessage的时候，调用了getPackageInfoNoCheck方法来获取待启动的组件信息。在这个方法中会优先查找<code>mPackages</code>中的缓存信息，而我们已经手动把插件信息添加进去；因此能够成功命中缓存，获取到独立存在的插件信息。</li><li><code>H</code>类然后调用handleLaunchActivity最终转发到performLaunchActivity方法；这个方法使用从getPackageInfoNoCheck中拿到LoadedApk中的mClassLoader来加载Activity类，进而使用反射创建Activity实例；接着创建Application，Context等完成Activity组件的启动。</li></ol><p>看起来好像已经天衣无缝万事大吉了；但是运行一下会出现一个异常，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">04</span>-<span class="number">05</span> <span class="number">02</span>:<span class="number">49</span>:<span class="number">53.742</span>  <span class="number">11759</span>-<span class="number">11759</span>/com.weishu.upf.hook_classloader E/AndroidRuntime﹕ FATAL EXCEPTION: main</span><br><span class="line">    Process: com.weishu.upf.hook_classloader, PID: <span class="number">11759</span></span><br><span class="line">    java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.weishu.upf.ams_pms_hook.app/com.weishu.upf.ams_pms_hook.app.MainActivity&#125;: java.lang.RuntimeException: Unable to instantiate application android.app.Application: java.lang.IllegalStateException: Unable to get <span class="keyword">package</span> info <span class="keyword">for</span> com.weishu.upf.ams_pms_hook.app; is <span class="keyword">package</span> not installed?</span><br></pre></td></tr></table></figure><p>错误提示说是无法实例化 <code>Application</code>，而Application的创建也是在performLaunchActivity中进行的，这里有些蹊跷，我们仔细查看一下。</p><h4 id="绕过系统检查"><a href="#绕过系统检查" class="headerlink" title="绕过系统检查"></a>绕过系统检查</h4><p>通过ActivityThread的performLaunchActivity方法可以得知，Application通过LoadedApk的makeApplication方法创建，我们查看这个方法，在源码中发现了上文异常抛出的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (!mPackageName.equals(<span class="string">"android"</span>)) &#123;</span><br><span class="line">        initializeJavaContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="keyword">this</span>);</span><br><span class="line">    app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">            cl, appClass, appContext);</span><br><span class="line">    appContext.setOuterContext(app);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mActivityThread.mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Unable to instantiate application "</span> + appClass</span><br><span class="line">            + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>木有办法，我们只有一行一行地查看到底是哪里抛出这个异常的了；所幸代码不多。（所以说，缩小异常范围是一件多么重要的事情！！！）</p><p>第一句 getClassLoader() 没什么可疑的，虽然方法很长，但是它木有抛出任何异常（当然，它调用的代码可能抛出异常，万一找不到只能进一步深搜了；所以我觉得这里应该使用受检异常）。</p><p>然后我们看第二句，如果包名不是<code>android</code>开头，那么调用了一个叫做initializeJavaContextClassLoader的方法；我们查阅这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeJavaContextClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IPackageManager pm = ActivityThread.getPackageManager();</span><br><span class="line">    android.content.pm.PackageInfo pi;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pi = pm.getPackageInfo(mPackageName, <span class="number">0</span>, UserHandle.myUserId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to get package info for "</span></span><br><span class="line">                + mPackageName + <span class="string">"; is system dying?"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pi == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to get package info for "</span></span><br><span class="line">                + mPackageName + <span class="string">"; is package not installed?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> sharedUserIdSet = (pi.sharedUserId != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">boolean</span> processNameNotDefault =</span><br><span class="line">        (pi.applicationInfo != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">         !mPackageName.equals(pi.applicationInfo.processName));</span><br><span class="line">    <span class="keyword">boolean</span> sharable = (sharedUserIdSet || processNameNotDefault);</span><br><span class="line">    ClassLoader contextClassLoader =</span><br><span class="line">        (sharable)</span><br><span class="line">        ? <span class="keyword">new</span> WarningContextClassLoader()</span><br><span class="line">        : mClassLoader;</span><br><span class="line">    Thread.currentThread().setContextClassLoader(contextClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们找出了这个异常的来源：原来这里调用了<code>getPackageInfo</code>方法获取包的信息；而我们的插件<strong>并没有安装在系统上</strong>，因此系统肯定认为插件没有安装，这个方法肯定返回null。所以，我们还要欺骗一下PMS，让系统觉得<strong>插件已经安装在系统上了</strong>；至于如何欺骗 PMS，<a href="Hook机制之AMS&amp;PMS.md">Hook机制之AMS&amp;PMS</a> 有详细解释，这里直接给出代码，不赘述了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookPackageManager</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一步是因为 initializeJavaContextClassLoader 这个方法内部无意中检查了这个包是否在系统安装</span></span><br><span class="line">    <span class="comment">// 如果没有安装, 直接抛出异常, 这里需要临时Hook掉 PMS, 绕过这个检查.</span></span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">    Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">    currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取ActivityThread里面原始的 sPackageManager</span></span><br><span class="line">    Field sPackageManagerField = activityThreadClass.getDeclaredField(<span class="string">"sPackageManager"</span>);</span><br><span class="line">    sPackageManagerField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object sPackageManager = sPackageManagerField.get(currentActivityThread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备好代理对象, 用来替换原始的对象</span></span><br><span class="line">    Class&lt;?&gt; iPackageManagerInterface = Class.forName(<span class="string">"android.content.pm.IPackageManager"</span>);</span><br><span class="line">    Object proxy = Proxy.newProxyInstance(iPackageManagerInterface.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> Class&lt;?&gt;[] &#123; iPackageManagerInterface &#125;,</span><br><span class="line">            <span class="keyword">new</span> IPackageManagerHookHandler(sPackageManager));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 替换掉ActivityThread里面的 sPackageManager 字段</span></span><br><span class="line">    sPackageManagerField.set(currentActivityThread, proxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK到这里，我们已经能够成功地加载<strong>简单的</strong>独立的存在于外部文件系统中的apk了。至此 关于 DroidPlugin 对于Activity生命周期的管理已经完全讲解完毕了；这是一种极其复杂的Activity管理方案，我们仅仅写一个用来理解的demo就Hook了相当多的东西，在Framework层来回牵扯；这其中的来龙去脉要完全把握清楚还请读者亲自翻阅源码。另外，我在此 对DroidPlugin 作者献上我的膝盖～这其中的玄妙让人叹为观止！</p><p>上文给出的方案中，我们全盘接管了插件中类的加载过程，这是一种相对暴力的解决方案；能不能更温柔一点呢？通俗来说，我们可以选择改革，而不是革命——告诉系统ClassLoader一些必要信息，让它帮忙完成插件类的加载。</p><h2 id="保守方案：委托系统，让系统帮忙加载"><a href="#保守方案：委托系统，让系统帮忙加载" class="headerlink" title="保守方案：委托系统，让系统帮忙加载"></a>保守方案：委托系统，让系统帮忙加载</h2><p>我们再次搬出ActivityThread中加载Activity类的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">activity = mInstrumentation.newActivity(</span><br><span class="line">        cl, component.getClassName(), r.intent);</span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure><p>我们知道 这个r.packageInfo中的<code>r</code>是通过getPackageInfoNoCheck获取到的；在『激进方案』中我们把插件apk手动添加进缓存，采用自己加载办法解决；如果我们不干预这个过程，导致无法命中mPackages中的缓存，会发生什么？</p><p>查阅 getPackageInfo方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LoadedApk <span class="title">getPackageInfo</span><span class="params">(ApplicationInfo aInfo, CompatibilityInfo compatInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassLoader baseLoader, <span class="keyword">boolean</span> securityViolation, <span class="keyword">boolean</span> includeCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> registerPackage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> differentUser = (UserHandle.myUserId() != UserHandle.getUserId(aInfo.uid));</span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">        WeakReference&lt;LoadedApk&gt; ref;</span><br><span class="line">        <span class="keyword">if</span> (differentUser) &#123;</span><br><span class="line">            <span class="comment">// Caching not supported across users</span></span><br><span class="line">            ref = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (includeCode) &#123;</span><br><span class="line">            ref = mPackages.get(aInfo.packageName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ref = mResourcePackages.get(aInfo.packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LoadedApk packageInfo = ref != <span class="keyword">null</span> ? ref.get() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span> || (packageInfo.mResources != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;</span><br><span class="line">            packageInfo =</span><br><span class="line">                <span class="keyword">new</span> LoadedApk(<span class="keyword">this</span>, aInfo, compatInfo, baseLoader,</span><br><span class="line">                        securityViolation, includeCode &amp;&amp;</span><br><span class="line">                        (aInfo.flags&amp;ApplicationInfo.FLAG_HAS_CODE) != <span class="number">0</span>, registerPackage);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，没有命中缓存的情况下，系统直接new了一个LoadedApk；注意这个构造函数的第二个参数<code>aInfo</code>，这是一个ApplicationInfo类型的对象。在『激进方案』中我们为了获取独立插件的ApplicationInfo花了不少心思；那么如果不做任何处理这里传入的这个<code>aInfo</code>参数是什么？</p><p>追本溯源不难发现，这个aInfo是从我们的替身StubActivity中获取的！而StubActivity存在于宿主程序中，所以，这个<code>aInfo</code>对象代表的实际上就是宿主程序的Application信息！</p><p>我们知道，接下来会使用new出来的这个LoadedApk的getClassLoader()方法获取到ClassLoader来对插件的类进行加载；而获取到的这个ClassLoader是宿主程序使用的ClassLoader，因此现在还无法加载插件的类；那么，<strong>我们能不能让宿主的ClasLoader获得加载插件类的能力呢？</strong>；如果我们告诉宿主使用的ClassLoader插件使用的类在哪里，就能帮助他完成加载！</p><h3 id="宿主的ClassLoader在哪里，是唯一的吗？"><a href="#宿主的ClassLoader在哪里，是唯一的吗？" class="headerlink" title="宿主的ClassLoader在哪里，是唯一的吗？"></a>宿主的ClassLoader在哪里，是唯一的吗？</h3><p>上面说到，我们可以通过告诉宿主程序的ClassLoader插件使用的类，让宿主的ClasLoader完成对于插件类的加载；那么问题来了，我们如何获取到宿主的ClassLoader？宿主程序使用的ClasLoader默认情况下是全局唯一的吗？</p><p>答案是肯定的。</p><p>因为在FrameWork中宿主程序也是使用LoadedApk表示的，如同Activity启动是加载Activity类一样，宿主中的类也都是通过LoadedApk的getClassLoader()方法得到的ClassLoader加载的；由类加载机制的『双亲委派』特性，只要有一个应用程序类由某一个ClassLoader加载，那么它引用到的别的类除非父加载器能加载，否则都是由这同一个加载器加载的（不遵循双亲委派模型的除外）。</p><p>表示宿主的LoadedApk在Application类中有一个成员变量<code>mLoadedApk</code>，而这个变量是从ContextImpl中获取的；ContextImpl重写了getClassLoader方法，因此<strong>我们在Context环境中直接getClassLoader()获取到的就是宿主程序唯一的ClassLoader</strong>。</p><h3 id="LoadedApk的ClassLoader到底是什么？"><a href="#LoadedApk的ClassLoader到底是什么？" class="headerlink" title="LoadedApk的ClassLoader到底是什么？"></a>LoadedApk的ClassLoader到底是什么？</h3><p>现在我们确保了『使用宿主ClassLoader帮助加载插件类』可行性；那么我们应该如何完成这个过程呢？</p><p>知己知彼，百战不殆。</p><p>不论是宿主程序还是插件程序都是通过LoadedApk的getClassLoader()方法返回的ClassLoader进行类加载的，返回的这个ClassLoader到底是个什么东西？？这个方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mClassLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mClassLoader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mIncludeCode &amp;&amp; !mPackageName.equals(<span class="string">"android"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 略...</span></span><br><span class="line">            mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip, lib,</span><br><span class="line">                    mBaseClassLoader);</span><br><span class="line"></span><br><span class="line">            StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mBaseClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mClassLoader = mBaseClassLoader;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，非<code>android</code>开头的包和<code>android</code>开头的包分别使用了两种不同的ClassLoader，我们只关心第一种；因此继续跟踪ApplicationLoaders类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">(String zip, String libPath, ClassLoader parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLoaders) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent = baseParent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent == baseParent) &#123;</span><br><span class="line">            ClassLoader loader = mLoaders.get(zip);</span><br><span class="line">            <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> loader;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);</span><br><span class="line">            PathClassLoader pathClassloader =</span><br><span class="line">                <span class="keyword">new</span> PathClassLoader(zip, libPath, parent);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">            mLoaders.put(zip, pathClassloader);</span><br><span class="line">            <span class="keyword">return</span> pathClassloader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);</span><br><span class="line">        PathClassLoader pathClassloader = <span class="keyword">new</span> PathClassLoader(zip, parent);</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        <span class="keyword">return</span> pathClassloader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，应用程序使用的ClassLoader都是PathClassLoader类的实例。那么，这个PathClassLoader是什么呢？从Android SDK给出的源码只能看出这么多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SDK没有导出这个类的源码，我们去<a href="http://androidxref.com/6.0.1_r10/xref/libcore/dalvik/src/main/java/dalvik/system/PathClassLoader.java" target="_blank" rel="noopener">androidxref</a>上面看；发现其实这个类真的就这么多内容；我们继续查看它的父类<a href="http://androidxref.com/6.0.1_r10/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java" target="_blank" rel="noopener">BaseDexClassLoader</a>；ClassLoader嘛，我们查看findClass或者defineClass方法，BaseDexClassLoader的findClass方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">    Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Didn't find class \""</span> + name + <span class="string">"\" on path: "</span> + pathList);</span><br><span class="line">        <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">            cnfe.addSuppressed(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> cnfe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，查找Class的任务通过<code>pathList</code>完成；这个<code>pathList</code>是一个<code>DexPathList</code>类的对象，它的<code>findClass</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">       DexFile dex = element.dexFile;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">           <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> clazz;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">       suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个DexPathList内部有一个叫做dexElements的数组，然后findClass的时候会遍历这个数组来查找Class；<strong>如果我们把插件的信息塞进这个数组里面，那么不就能够完成类的加载过程吗？！！</strong></p><h3 id="给默认ClassLoader打补丁"><a href="#给默认ClassLoader打补丁" class="headerlink" title="给默认ClassLoader打补丁"></a>给默认ClassLoader打补丁</h3><p>通过上述分析，我们知道，可以把插件的相关信息放入BaseDexClassLoader的表示dex文件的数组里面，这样宿主程序的ClassLoader在进行类加载，遍历这个数组的时候，会自动遍历到我们添加进去的插件信息，从而完成插件类的加载！</p><p>接下来，我们实现这个过程；我们会用到一些较为复杂的反射技术哦～不过代码非常短：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">patchClassLoader</span><span class="params">(ClassLoader cl, File apkFile, File optDexFile)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException, NoSuchMethodException, IOException, InvocationTargetException, InstantiationException, NoSuchFieldException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 BaseDexClassLoader : pathList</span></span><br><span class="line">    Field pathListField = DexClassLoader.class.getSuperclass().getDeclaredField(<span class="string">"pathList"</span>);</span><br><span class="line">    pathListField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object pathListObj = pathListField.get(cl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 PathList: Element[] dexElements</span></span><br><span class="line">    Field dexElementArray = pathListObj.getClass().getDeclaredField(<span class="string">"dexElements"</span>);</span><br><span class="line">    dexElementArray.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object[] dexElements = (Object[]) dexElementArray.get(pathListObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Element 类型</span></span><br><span class="line">    Class&lt;?&gt; elementClass = dexElements.getClass().getComponentType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个数组, 用来替换原始的数组</span></span><br><span class="line">    Object[] newElements = (Object[]) Array.newInstance(elementClass, dexElements.length + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造插件Element(File file, boolean isDirectory, File zip, DexFile dexFile) 这个构造函数</span></span><br><span class="line">    Constructor&lt;?&gt; constructor = elementClass.getConstructor(File.class, <span class="keyword">boolean</span>.class, File.class, DexFile.class);</span><br><span class="line">    Object o = constructor.newInstance(apkFile, <span class="keyword">false</span>, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(), optDexFile.getAbsolutePath(), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    Object[] toAddElementArray = <span class="keyword">new</span> Object[] &#123; o &#125;;</span><br><span class="line">    <span class="comment">// 把原始的elements复制进去</span></span><br><span class="line">    System.arraycopy(dexElements, <span class="number">0</span>, newElements, <span class="number">0</span>, dexElements.length);</span><br><span class="line">    <span class="comment">// 插件的那个element复制进去</span></span><br><span class="line">    System.arraycopy(toAddElementArray, <span class="number">0</span>, newElements, dexElements.length, toAddElementArray.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换</span></span><br><span class="line">    dexElementArray.set(pathListObj, newElements);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>短短的二十几行代码，我们就完成了『委托宿主ClassLoader加载插件类』的任务；因此第二种方案也宣告完成！我们简要总结一下这种方式的原理：</p><ol><li>默认情况下performLacunchActivity会使用替身StubActivity的ApplicationInfo也就是宿主程序的CLassLoader加载所有的类；我们的思路是告诉宿主ClassLoader我们在哪，让其帮助完成类加载的过程。</li><li>宿主程序的ClassLoader最终继承自BaseDexClassLoader，BaseDexClassLoader通过DexPathList进行类的查找过程；而这个查找通过遍历一个dexElements的数组完成；<strong>我们通过把插件dex添加进这个数组</strong>就让宿主ClasLoader获取了加载插件类的能力。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文中我们采用两种方案成功完成了『启动没有在AndroidManifest.xml中显示声明，并且存在于外部插件中的Activity』的任务。</p><p>『激进方案』中我们自定义了插件的ClassLoader，并且绕开了Framework的检测；利用ActivityThread对于LoadedApk的缓存机制，我们把携带这个自定义的ClassLoader的插件信息添加进<code>mPackages</code>中，进而完成了类的加载过程。</p><p>『保守方案』中我们深入探究了系统使用ClassLoader findClass的过程，发现应用程序使用的非系统类都是通过同一个PathClassLoader加载的；而这个类的最终父类BaseDexClassLoader通过DexPathList完成类的查找过程；我们hack了这个查找过程，从而完成了插件类的加载。</p><p>这两种方案孰优孰劣呢？</p><p>很显然，『激进方案』比较麻烦，从代码量和分析过程就可以看出来，这种机制异常复杂；而且在解析apk的时候我们使用的PackageParser的兼容性非常差，我们不得不手动处理每一个版本的apk解析api；另外，它Hook的地方也有点多：不仅需要Hook AMS和<code>H</code>，还需要Hook ActivityThread的<code>mPackages</code>和PackageManager！</p><p>『保守方案』则简单得多（虽然原理也不简单），不仅代码很少，而且Hook的地方也不多；有一点正本清源的意思，从最最上层Hook住了整个类的加载过程。</p><p>但是，我们不能简单地说『保守方案』比『激进方案』好。从根本上说，这两种方案的差异在哪呢？</p><p>『激进方案』是<strong>多ClassLoader构架</strong>，每一个插件都有一个自己的ClassLoader，因此类的隔离性非常好——如果不同的插件使用了同一个库的不同版本，它们相安无事！『保守方案』是<strong>单ClassLoader方案</strong>，插件和宿主程序的类全部都通过宿主的ClasLoader加载，虽然代码简单，但是鲁棒性很差；一旦插件之间甚至插件与宿主之间使用的类库有冲突，那么直接GG。</p><p>多ClassLoader还有一个优点：可以真正完成代码的热加载！如果插件需要升级，直接重新创建一个自定的ClassLoader加载新的插件，然后替换掉原来的版本即可（Java中，不同ClassLoader加载的同一个类被认为是不同的类）；单ClassLoader的话实现非常麻烦，有可能需要重启进程。</p><p>在J2EE领域中广泛使用ClasLoader的地方均采用多ClassLoader架构，比如Tomcat服务器，Java模块化事实标准的OSGi技术；所以，我们有足够的理由认为<strong>选择多ClassLoader架构在大多数情况下是明智之举</strong>。</p><p>目前开源的插件方案中，DroidPlugin采用的『激进方案』，Small采用的『保守方案』那么，有没有两种优点兼顾的方案呢？？</p><p>答案自然是有的。</p><p>DroidPlugin和Small的共同点是<strong>两者都是非侵入式的插件框架</strong>；什么是『非侵入式』呢？打个比方，你启动一个插件Activity，直接使用<code>startActivity</code>即可，就跟开发普通的apk一样，开发插件和普通的程序对于开发者来说没有什么区别。</p><p>如果我们一定程度上放弃这种『侵入性』，那么我们就能实现一个两者优点兼而有之的插件框架！这里我先卖个关子～</p><p>OK，本文的内容就到这里了；关于『插件机制对于Activity的处理方式』也就此完结。要说明的是，在本文的『保守方案』其实只处理了代码的加载过程，它并不能加载有资源的apk！所以目前我这个实现基本没什么暖用；当然我这里只是就『代码加载』进行举例；至于资源，那牵扯到另外一个问题——<strong>插件系统的资源管理机制</strong>这个在后续文章的合适机会我会单独讲解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;插件加载机制&quot;&gt;&lt;a href=&quot;#插件加载机制&quot; class=&quot;headerlink&quot; title=&quot;插件加载机制&quot;&gt;&lt;/a&gt;插件加载机制&lt;/h1&gt;&lt;p&gt;上文 &lt;a href=&quot;Activity生命周期管理.md&quot;&gt;Activity生命周期管理&lt;/a&gt; 中我们地完成了『启动没有在AndroidManifest.xml中显式声明的Activity』的任务；通过Hook &lt;code&gt;AMS&lt;/code&gt;和拦截ActivityThread中&lt;code&gt;H&lt;/code&gt;类对于组件调度我们成功地绕过了AndroidMAnifest.xml的限制。&lt;/p&gt;
&lt;p&gt;但是我们启动的『没有在AndroidManifet.xml中显式声明』的Activity和宿主程序存在于同一个Apk中；通常情况下，插件均以独立的文件存在甚至通过网络获取，这时候插件中的Activity能否成功启动呢？&lt;/p&gt;
&lt;p&gt;要启动Activity组件肯定先要创建对应的Activity类的对象，从上文 &lt;a href=&quot;Activity生命周期管理.md&quot;&gt;Activity生命周期管理&lt;/a&gt; 知道，创建Activity类对象的过程如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.lang.ClassLoader cl = r.packageInfo.getClassLoader();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;activity = mInstrumentation.newActivity(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cl, component.getClassName(), r.intent);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;StrictMode.incrementExpectedActivityCount(activity.getClass());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r.intent.setExtrasClassLoader(cl);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也就是说，系统通过&lt;code&gt;ClassLoader&lt;/code&gt;加载了需要的Activity类并通过反射调用构造函数创建出了Activity对象。如果Activity组件存在于独立于宿主程序的文件之中，系统的ClassLoader怎么知道去哪里加载呢？因此，如果不做额外的处理，插件中的Activity对象甚至都没有办法创建出来，谈何启动？&lt;/p&gt;
&lt;p&gt;因此，要使存在于独立文件或者网络中的插件被成功启动，首先就需要解决这个&lt;strong&gt;插件类加载&lt;/strong&gt;的问题。&lt;br&gt;下文将围绕此问题展开，完成『启动没有在AndroidManifest.xml中显示声明，并且存在于外部插件中的Activity』的任务。&lt;/p&gt;
&lt;p&gt;阅读本文之前，可以先clone一份 &lt;a href=&quot;https://github.com/tiann/understand-plugin-framework&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;understand-plugin-framework&lt;/a&gt;，参考此项目的&lt;code&gt;classloader-hook&lt;/code&gt; 模块。另外，插件框架原理解析系列文章见&lt;a href=&quot;概述.md&quot;&gt;索引&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android插件化原理解析——BroadcastReceiver插件化</title>
    <link href="https://zhanqq2010.github.io/2018/01/11/BroadcastReceiver%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    <id>https://zhanqq2010.github.io/2018/01/11/BroadcastReceiver插件化/</id>
    <published>2018-01-11T04:03:39.489Z</published>
    <updated>2018-01-11T04:04:14.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BroadcastReceiver插件化"><a href="#BroadcastReceiver插件化" class="headerlink" title="BroadcastReceiver插件化"></a>BroadcastReceiver插件化</h1><p>在<a href="Activity生命周期管理.md">Activity生命周期管理</a> 以及 <a href="ClassLoader管理.md">插件加载机制</a> 中我们详细讲述了插件化过程中对于Activity组件的处理方式，为了实现Activity的插件化我们付出了相当多的努力；那么Android系统的其他组件，比如BroadcastReceiver，Service还有ContentProvider，它们又该如何处理呢？</p><p>相比Activity，BroadcastReceiver要简单很多——广播的生命周期相当简单；如果希望插件能够支持广播，这意味着什么？</p><p>回想一下我们日常开发的时候是如何使用BroadcastReceiver的：<strong>注册</strong>, <strong>发送</strong>和<strong>接收</strong>；因此，要实现BroadcastReceiver的插件化就这三种操作提供支持；接下来我们将一步步完成这个过程。</p><p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>，参考此项目的<code>receiver-management</code> 模块。另外，插件框架原理解析系列文章见<a href="概述.md">索引</a>。</p><a id="more"></a><p>如果连BroadcastReceiver的工作原理都不清楚，又怎么能让插件支持它？老规矩，知己知彼。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们可以注册一个BroadcastReceiver然后接收我们感兴趣的广播，也可以给某有缘人发出某个广播；因此，我们对源码的分析按照两条路线展开：</p><h3 id="注册过程"><a href="#注册过程" class="headerlink" title="注册过程"></a>注册过程</h3><p>不论是静态广播还是动态广播，在使用之前都是需要注册的；动态广播的注册需要借助Context类的registerReceiver方法，而静态广播的注册直接在AndroidManifest.xml中声明即可；我们首先分析一下动态广播的注册过程。</p><p>Context类的registerReceiver的真正实现在ContextImpl里面，而这个方法间接调用了registerReceiverInternal，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Intent <span class="title">registerReceiverInternal</span><span class="params">(BroadcastReceiver receiver, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        IntentFilter filter, String broadcastPermission,</span></span></span><br><span class="line"><span class="function"><span class="params">        Handler scheduler, Context context)</span> </span>&#123;</span><br><span class="line">    IIntentReceiver rd = <span class="keyword">null</span>; <span class="comment">// Important !!!!!</span></span><br><span class="line">    <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span> &amp;&amp; context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                receiver, context, scheduler,</span><br><span class="line">                mMainThread.getInstrumentation(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = <span class="keyword">new</span> LoadedApk.ReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler, <span class="keyword">null</span>, <span class="keyword">true</span>).getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ActivityManagerNative.getDefault().registerReceiver(</span><br><span class="line">                mMainThread.getApplicationThread(), mBasePackageName,</span><br><span class="line">                rd, filter, broadcastPermission, userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，BroadcastReceiver的注册也是通过<code>AMS</code>完成的；在进入<code>AMS</code>跟踪它的registerReceiver方法之前，我们先弄清楚这个<code>IIntentReceiver</code>类型的变量<code>rd</code>是什么。首先查阅API文档，很遗憾SDK里面没有导出这个类，我们直接去 <a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.0.1_r1/android/content/IIntentReceiver.java?av=f" target="_blank" rel="noopener">grepcode</a> 上看，文档如下：</p><blockquote><p>System private API for dispatching intent broadcasts. This is given to the activity manager as part of registering for an intent broadcasts, and is called when it receives intents.</p></blockquote><p>这个类是通过AIDL工具生成的，它是一个Binder对象，因此可以用来跨进程传输；文档说的很清楚，它是用来进行广播分发的。什么意思呢？</p><p>由于广播的分发过程是在AMS中进行的，而AMS所在的进程和BroadcastReceiver所在的进程不一样，因此要把广播分发到BroadcastReceiver具体的进程需要进行跨进程通信，这个<strong>通信的载体</strong>就是IIntentReceiver类。其实这个类的作用跟 <a href="Activity生命周期管理.md">Activity生命周期管理</a> 中提到的 <code>IApplicationThread</code>相同，都是App进程给AMS进程用来进行通信的对象。另外，<code>IIntentReceiver</code>是一个接口，从上述代码中可以看出，它的实现类为LoadedApk.ReceiverDispatcher。</p><p>OK，我们继续跟踪源码，AMS类的registerReceiver方法代码有点多，这里不一一解释了，感兴趣的话可以自行查阅；这个方法主要做了以下两件事：</p><ol><li>对发送者的身份和权限做出一定的校检</li><li>把这个BroadcastReceiver以BroadcastFilter的形式存储在AMS的<code>mReceiverResolver</code>变量中，供后续使用。</li></ol><p>就这样，被传递过来的BroadcastReceiver已经成功地注册在系统之中，能够接收特定类型的广播了；那么注册在AndroidManifest.xml中的静态广播是如何被系统感知的呢？</p><p>在 <a href="ClassLoader管理.md">插件加载机制</a> 中我们知道系统会通过PackageParser解析Apk中的AndroidManifest.xml文件，因此我们有理由认为，系统会在解析AndroidMafest.xml的&lt;receiver&gt;标签（也即静态注册的广播）的时候保存相应的信息；而Apk的解析过程是在PMS中进行的，因此<strong>静态注册广播的信息存储在PMS中</strong>。接下来的分析会证实这一结论。</p><h3 id="发送和接收过程"><a href="#发送和接收过程" class="headerlink" title="发送和接收过程"></a>发送和接收过程</h3><h4 id="发送过程"><a href="#发送过程" class="headerlink" title="发送过程"></a>发送过程</h4><p>发送广播很简单，就是一句context.sendBroadcast()，我们顺藤摸瓜，跟踪这个方法。前文也提到过，Context中方法的调用都会委托到ContextImpl这个类，我们直接看ContextImpl对这个方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.prepareToLeaveProcess();</span><br><span class="line">        ActivityManagerNative.getDefault().broadcastIntent(</span><br><span class="line">                mMainThread.getApplicationThread(), intent, resolvedType, <span class="keyword">null</span>,</span><br><span class="line">                Activity.RESULT_OK, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, AppOpsManager.OP_NONE, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">                getUserId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，发送广播也是通过AMS进行的，我们直接查看ActivityManagerService类的broadcastIntent方法，这个方法仅仅是调用了broadcastIntentLocked方法，我们继续跟踪；broadcastIntentLocked这个方法相当长，处理了诸如粘性广播，顺序广播，各种Flag以及动态广播静态广播的接收过程，这些我们暂时不关心；值得注意的是，在这个方法中我们发现，其实<strong>广播的发送和接收是融为一体的</strong>。某个广播被发送之后，AMS会找出所有注册过的BroadcastReceiver中与这个广播匹配的接收者，然后将这个广播分发给相应的接收者处理。</p><h4 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h4><p>某一条广播被发出之后，并不是阿猫阿狗都能接收它并处理的；BroadcastReceiver可能只对某些类型的广播感兴趣，因此它也只能接收和处理这种特定类型的广播；在broadcastIntentLocked方法内部有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure out who all will receive this broadcast.</span></span><br><span class="line">List receivers = <span class="keyword">null</span>;</span><br><span class="line">List&lt;BroadcastFilter&gt; registeredReceivers = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// Need to resolve the intent to interested receivers...</span></span><br><span class="line"><span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)</span><br><span class="line">         == <span class="number">0</span>) &#123;</span><br><span class="line">    receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (intent.getComponent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userId == UserHandle.USER_ALL &amp;&amp; callingUid == Process.SHELL_UID) &#123;</span><br><span class="line">        <span class="comment">// Query one target user at a time, excluding shell-restricted users</span></span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        registeredReceivers = mReceiverResolver.queryIntent(intent,</span><br><span class="line">                resolvedType, <span class="keyword">false</span>, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个列表<code>receivers</code>和<code>registeredReceivers</code>，看名字好像是广播接收者的列表；下面是它们的赋值过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">registeredReceivers = mReceiverResolver.queryIntent(intent, resolvedType, <span class="keyword">false</span>, userId);</span><br></pre></td></tr></table></figure><p>读者可以自行跟踪这两个方法的代码，过程比较简单，我这里直接给出结论：</p><ol><li><code>receivers</code>是对这个广播感兴趣的<strong>静态BroadcastReceiver</strong>列表；collectReceiverComponents 通过PackageManager获取了与这个广播匹配的静态BroadcastReceiver信息；这里也证实了我们在分析BroadcasrReceiver注册过程中的推论——静态BroadcastReceiver的注册过程的确实在PMS中进行的。</li><li><code>mReceiverResolver</code>存储了<strong>动态注册</strong>的BroadcastReceiver的信息；还记得这个<code>mReceiverResolver</code>吗？我们在分析动态广播的注册过程中发现，动态注册的BroadcastReceiver的相关信息最终存储在此对象之中；在这里，通过mReceiverResolver对象匹配出了对应的BroadcastReceiver供进一步使用。</li></ol><p>现在系统通过PMS拿到了所有符合要求的静态BroadcastReceiver，然后从AMS中获取了符合要求的动态BroadcastReceiver；因此接下来的工作非常简单：唤醒这些广播接受者。简单来说就是回调它们的<code>onReceive</code>方法。</p><h4 id="接收过程"><a href="#接收过程" class="headerlink" title="接收过程"></a>接收过程</h4><p>通过上文的分析过程我们知道，在AMS的broadcastIntentLocked方法中找出了符合要求的所有BroadcastReceiver；接下来就需要把这个广播分发到这些接收者之中。在broadcastIntentLocked方法的后半部分有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">        callerPackage, callingPid, callingUid, resolvedType,</span><br><span class="line">        requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">        resultData, resultExtras, ordered, sticky, <span class="keyword">false</span>, userId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</span><br><span class="line"><span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">    queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">    queue.scheduleBroadcastsLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建了一个BroadcastRecord代表此次发送的这条广播，然后把它丢进一个队列，最后通过scheduleBroadcastsLocked通知队列对广播进行处理。</p><p>在BroadcastQueue中通过Handle调度了对于广播处理的消息，调度过程由processNextBroadcast方法完成，而这个方法通过performReceiveLocked最终调用了IIntentReceiver的performReceive方法。</p><p>这个<code>IIntentReceiver</code>正是在广播注册过程中由App进程提供给AMS进程的Binder对象，现在AMS通过这个Binder对象进行IPC调用通知广播接受者所在进程完成余下操作。在上文我们分析广播的注册过程中提到过，这个IItentReceiver的实现是LoadedApk.ReceiverDispatcher；我们查看这个对象的performReceive方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String data,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">    Args args = <span class="keyword">new</span> Args(intent, resultCode, data, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">    <span class="keyword">if</span> (!mActivityThread.post(args)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">            args.sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法创建了一个<code>Args</code>对象，然后把它post到了mActivityThread这个Handler中；我们查看<code>Args</code>类的<code>run</code>方法：(坚持一下，马上就分析完了 ^ ^)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BroadcastReceiver receiver = mReceiver;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> ordered = mOrdered;  </span><br><span class="line">    <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">    <span class="keyword">final</span> Intent intent = mCurIntent;</span><br><span class="line">    mCurIntent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (receiver == <span class="keyword">null</span> || mForgotten) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ClassLoader cl =  mReceiver.getClass().getClassLoader(); <span class="comment">// Important!! load class</span></span><br><span class="line">        intent.setExtrasClassLoader(cl);</span><br><span class="line">        setExtrasClassLoader(cl);</span><br><span class="line">        receiver.setPendingResult(<span class="keyword">this</span>);</span><br><span class="line">        receiver.onReceive(mContext, intent); <span class="comment">// callback</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mInstrumentation == <span class="keyword">null</span> ||</span><br><span class="line">                !mInstrumentation.onException(mReceiver, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Error receiving broadcast "</span> + intent</span><br><span class="line">                + <span class="string">" in "</span> + mReceiver, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (receiver.getPendingResult() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们看到了相应BroadcastReceiver的<code>onReceive</code>回调；因此，广播的工作原理到这里就水落石出了；我们接下来将探讨如何实现对于广播的插件化。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>上文中我们分析了BroadcastReceiver的工作原理，那么怎么才能实现对BroadcastReceiver的插件化呢？</p><p>从分析过程中我们发现，Framework对于静态广播和动态广播的处理是不同的；不过，这个不同之处仅仅体现在<strong>注册过程</strong>——静态广播需要在AndroidManifest.xml中注册，并且注册的信息存储在PMS中；动态广播不需要预注册，注册的信息存储在AMS中。</p><p>从实现Activity的插件化过程中我们知道，需要在AndroidManifest.xml中预先注册是一个相当麻烦的事情——我们需要使用『替身』并在合适的时候进行『偷梁换柱』；因此看起来动态广播的处理要容易那么一点，我们先讨论一下如何实现动态注册BroadcastReceiver的插件化。</p><p>首先，广播并没有复杂的生命周期，它的整个存活过程其实就是一个<code>onReceive</code>回调；而动态广播又不需要在AndroidManifest.xml中预先注册，所以动态注册的BroadcastReceiver其实可以当作一个普通的Java对象；我们完全可以用纯ClassLoader技术实现它——不就是把插件中的Receiver加载进来，然后想办法让它能接受<code>onReceive</code>回调嘛。</p><p>静态BroadcastReceiver看起来要复杂一些，但是我们连Activity都搞定了，还有什么难得到我们呢？对于实现静态BroadcastReceiver插件化的问题，有的童鞋或许会想，我们可以借鉴Activity的工作方式——用替身和Hook解决。但是很遗憾，这样是行不通的。为什么呢？</p><p>BroadcastReceiver有一个IntentFilter的概念，也就是说，每一个BroadcastReceiver只对特定的Broadcast感兴趣；而且，AMS在进行广播分发的时候，也会对这些BroadcastReceiver与发出的广播进行匹配，只有Intent匹配的Receiver才能收到广播；在分析源码的时候也提到了这个匹配过程。如果我们尝试用替身Receiver解决静态注册的问题，那么它的IntentFilter该写什么？我们无法预料插件中静态注册的Receiver会使用什么类型的IntentFilter，就算我们在AndroidManifest.xml中声明替身也没有用——我们压根儿收不到与我们的IntentFilter不匹配的广播。其实，我们对于Activity的处理方式也有这个问题；如果你尝试用IntentFilter的方式启动Activity，这并不能成功；这算得上是DroidPlugin的缺陷之一。</p><p>那么，我们就真的对静态BroadcastReceiver无能为力吗？想一想这里的难点是什么？</p><p>没错，主要是在静态BroadcastReceiver里面这个IntentFilter我们事先无法确定，它是动态变化的；但是，动态BroadcastReceiver不是可以动态添加IntentFilter吗！！！</p><p><strong>可以把静态广播当作动态广播处理</strong></p><p>既然都是广播，它们的功能都是订阅一个特定的消息然后执行某个特定的操作，我们完全可以把插件中的静态广播全部注册为动态广播，这样就解决了静态广播的问题。当然，这样也是有缺陷的，静态BroadcastReceiver与动态BroadcastReceiver一个非常大的不同之处在于：动态BroadcastReceiver在进程死亡之后是无法接收广播的，而静态BroadcastReceiver则可以——系统会唤醒Receiver所在进程；这算得上缺陷之二，当然，瑕不掩瑜。</p><h2 id="静态广播非静态的实现"><a href="#静态广播非静态的实现" class="headerlink" title="静态广播非静态的实现"></a>静态广播非静态的实现</h2><p>上文我们提到，可以把静态BroadcastReceiver当作动态BroadcastReceiver处理；我们接下来实现这个过程。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>要把插件中的静态BroadcastReceiver当作动态BroadcastReceiver处理，我们首先得知道插件中到底注册了哪些广播；这个过程归根结底就是获取AndroidManifest.xml中的&lt;receiver&gt;标签下面的内容，我们可以选择手动解析xml文件；这里我们选择使用系统的 PackageParser 帮助解析，这种方式在之前的 [插件加载过程][] 中也用到过，如果忘记了可以温习一下。</p><p>PackageParser中有一系列方法用来提取Apk中的信息，可是翻遍了这个类也没有找到与「Receiver」名字相关的方法；最终我们发现BroadcastReceiver信息是用与Activity相同的类存储的！这一点可以在PackageParser的内部类Package中发现端倪——成员变量<code>receivers</code>和<code>activities</code>的范型类型相同。所以，我们要解析apk的&lt;receiver&gt;的信息，可以使用PackageParser的<code>generateActivityInfo</code>方法。</p><p>知道这一点之后，代码就比较简单了；使用反射调用相应的隐藏接口，并且在必要的时候构造相应参数的方式我们在插件化系列文章中已经讲述过很多，相信读者已经熟练，这里就不赘述，直接贴代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parserReceivers</span><span class="params">(File apkFile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;?&gt; packageParserClass = Class.forName(<span class="string">"android.content.pm.PackageParser"</span>);</span><br><span class="line">    Method parsePackageMethod = packageParserClass.getDeclaredMethod(<span class="string">"parsePackage"</span>, File.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">    Object packageParser = packageParserClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先调用parsePackage获取到apk对象对应的Package对象</span></span><br><span class="line">    Object packageObj = parsePackageMethod.invoke(packageParser, apkFile, PackageManager.GET_RECEIVERS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取Package对象里面的receivers字段,注意这是一个 List&lt;Activity&gt; (没错,底层把&lt;receiver&gt;当作&lt;activity&gt;处理)</span></span><br><span class="line">    <span class="comment">// 接下来要做的就是根据这个List&lt;Activity&gt; 获取到Receiver对应的 ActivityInfo (依然是把receiver信息用activity处理了)</span></span><br><span class="line">    Field receiversField = packageObj.getClass().getDeclaredField(<span class="string">"receivers"</span>);</span><br><span class="line">    List receivers = (List) receiversField.get(packageObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用generateActivityInfo 方法, 把PackageParser.Activity 转换成</span></span><br><span class="line">    Class&lt;?&gt; packageParser$ActivityClass = Class.forName(<span class="string">"android.content.pm.PackageParser$Activity"</span>);</span><br><span class="line">    Class&lt;?&gt; packageUserStateClass = Class.forName(<span class="string">"android.content.pm.PackageUserState"</span>);</span><br><span class="line">    Class&lt;?&gt; userHandler = Class.forName(<span class="string">"android.os.UserHandle"</span>);</span><br><span class="line">    Method getCallingUserIdMethod = userHandler.getDeclaredMethod(<span class="string">"getCallingUserId"</span>);</span><br><span class="line">    <span class="keyword">int</span> userId = (Integer) getCallingUserIdMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line">    Object defaultUserState = packageUserStateClass.newInstance();</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; componentClass = Class.forName(<span class="string">"android.content.pm.PackageParser$Component"</span>);</span><br><span class="line">    Field intentsField = componentClass.getDeclaredField(<span class="string">"intents"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要调用 android.content.pm.PackageParser#generateActivityInfo(android.content.pm.ActivityInfo, int, android.content.pm.PackageUserState, int)</span></span><br><span class="line">    Method generateReceiverInfo = packageParserClass.getDeclaredMethod(<span class="string">"generateActivityInfo"</span>,</span><br><span class="line">            packageParser$ActivityClass, <span class="keyword">int</span>.class, packageUserStateClass, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析出 receiver以及对应的 intentFilter</span></span><br><span class="line">    <span class="keyword">for</span> (Object receiver : receivers) &#123;</span><br><span class="line">        ActivityInfo info = (ActivityInfo) generateReceiverInfo.invoke(packageParser, receiver, <span class="number">0</span>, defaultUserState, userId);</span><br><span class="line">        List&lt;? extends IntentFilter&gt; filters = (List&lt;? extends IntentFilter&gt;) intentsField.get(receiver);</span><br><span class="line">        sCache.put(info, filters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>我们已经解析得到了插件中静态注册的BroadcastReceiver的信息，现在我们只需要把这些静态广播动态注册一遍就可以了；但是，由于BroadcastReceiver的实现类存在于插件之后，我们需要手动用ClassLoader来加载它；这一点在 <a href="ClassLoader管理.md">插件加载机制</a> 已有讲述，不啰嗦了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (ActivityInfo activityInfo : ReceiverHelper.sCache.keySet()) &#123;</span><br><span class="line">    Log.i(TAG, <span class="string">"preload receiver:"</span> + activityInfo.name);</span><br><span class="line">    List&lt;? extends IntentFilter&gt; intentFilters = ReceiverHelper.sCache.get(activityInfo);</span><br><span class="line">    <span class="keyword">if</span> (cl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cl = CustomClassLoader.getPluginClassLoader(apk, activityInfo.packageName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把解析出来的每一个静态Receiver都注册为动态的</span></span><br><span class="line">    <span class="keyword">for</span> (IntentFilter intentFilter : intentFilters) &#123;</span><br><span class="line">        BroadcastReceiver receiver = (BroadcastReceiver) cl.loadClass(activityInfo.name).newInstance();</span><br><span class="line">        context.registerReceiver(receiver, intentFilter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样，我们对插件静态BroadcastReceiver的支持已经完成了，是不是相当简单？至于插件中的动态广播如何实现插件化，这一点<strong>交给读者自行完成</strong>，希望你在解决这个问题的过程中能够加深对于插件方案的理解 ^ ^</p><h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>本文我们介绍了BroadcastReceiver组件的插件化方式，可以看到，插件方案对于BroadcastReceiver的处理相对简单；同时「静态广播非静态」的特性以及BroadcastReceiver先天的一些特点导致插件方案没有办法做到尽善尽美，不过这都是大醇小疵——在绝大多数情况下，这样的处理方式是可以满足需求的。</p><p>虽然对于BroadcastReceiver的处理方式相对简单，但是文章的内容却并不短——我们花了大量的篇幅讲述BroadcastReceiver的原理，这也是我的初衷：借助DroidPlugin更深入地了解Android Framework。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BroadcastReceiver插件化&quot;&gt;&lt;a href=&quot;#BroadcastReceiver插件化&quot; class=&quot;headerlink&quot; title=&quot;BroadcastReceiver插件化&quot;&gt;&lt;/a&gt;BroadcastReceiver插件化&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;Activity生命周期管理.md&quot;&gt;Activity生命周期管理&lt;/a&gt; 以及 &lt;a href=&quot;ClassLoader管理.md&quot;&gt;插件加载机制&lt;/a&gt; 中我们详细讲述了插件化过程中对于Activity组件的处理方式，为了实现Activity的插件化我们付出了相当多的努力；那么Android系统的其他组件，比如BroadcastReceiver，Service还有ContentProvider，它们又该如何处理呢？&lt;/p&gt;
&lt;p&gt;相比Activity，BroadcastReceiver要简单很多——广播的生命周期相当简单；如果希望插件能够支持广播，这意味着什么？&lt;/p&gt;
&lt;p&gt;回想一下我们日常开发的时候是如何使用BroadcastReceiver的：&lt;strong&gt;注册&lt;/strong&gt;, &lt;strong&gt;发送&lt;/strong&gt;和&lt;strong&gt;接收&lt;/strong&gt;；因此，要实现BroadcastReceiver的插件化就这三种操作提供支持；接下来我们将一步步完成这个过程。&lt;/p&gt;
&lt;p&gt;阅读本文之前，可以先clone一份 &lt;a href=&quot;https://github.com/tiann/understand-plugin-framework&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;understand-plugin-framework&lt;/a&gt;，参考此项目的&lt;code&gt;receiver-management&lt;/code&gt; 模块。另外，插件框架原理解析系列文章见&lt;a href=&quot;概述.md&quot;&gt;索引&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android插件化原理解析——Activity生命周期管理</title>
    <link href="https://zhanqq2010.github.io/2018/01/11/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/"/>
    <id>https://zhanqq2010.github.io/2018/01/11/Activity生命周期管理/</id>
    <published>2018-01-11T04:03:39.486Z</published>
    <updated>2018-01-11T04:04:00.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Activity生命周期管理"><a href="#Activity生命周期管理" class="headerlink" title="Activity生命周期管理"></a>Activity生命周期管理</h1><p>之前的 <a href="概述.md">Android插件化原理解析</a> 系列文章揭开了Hook机制的神秘面纱，现在我们手握倚天屠龙，那么如何通过这种技术完成插件化方案呢？具体来说，插件中的Activity，Service等组件如何在Android系统上运行起来？</p><p>在Java平台要做到动态运行模块、热插拔可以使用<code>ClassLoader</code>技术进行动态类加载，比如广泛使用的<code>OSGi</code>技术。在Android上当然也可以使用动态加载技术，但是仅仅把类加载进来就足够了吗？<code>Activity</code>，<code>Service</code>等组件是有生命周期的，它们统一由系统服务<code>AMS</code>管理；使用<code>ClassLoader</code>可以从插件中创建Activity对象，但是，一个没有生命周期的Activity对象有什么用？所以在Android系统上，仅仅完成动态类加载是不够的；我们需要想办法把我们加载进来的Activity等组件交给系统管理，让<code>AMS</code>赋予组件生命周期；这样才算是一个有血有肉的完善的插件化方案。</p><p>接下来的系列文章会讲述 DroidPlugin对于Android四大组件的处理方式，我们且看它如何采用Hook技术坑蒙拐骗把系统玩弄于股掌之中，最终赋予Activity，Service等组件生命周期，完成借尸还魂的。</p><a id="more"></a><p>首先，我们来看看DroidPlugin对于<code>Activity</code>组件的处理方式。</p><p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>，参考此项目的intercept-activity模块。另外，如果对于Hook技术不甚了解，请先查阅我之前的文章：</p><ol><li><a href="Hook机制之代理Hook.md">Hook机制之动态代理</a></li><li><a href="Hook机制之Binder-Hook.md">Hook机制之Binder Hook</a></li><li><a href="Hook机制之AMS&amp;PMS.md">Hook机制之AMS&amp;PMS</a></li></ol><h2 id="AndroidManifest-xml的限制"><a href="#AndroidManifest-xml的限制" class="headerlink" title="AndroidManifest.xml的限制"></a>AndroidManifest.xml的限制</h2><p>读到这里，或许有部分读者觉得疑惑了，启动Activity不就是一个<code>startActivity</code>的事吗，有这么神秘兮兮的？</p><p>启动Activity确实非常简单，但是Android却有一个限制：<strong>必须在AndroidManifest.xml中显示声明使用的Activity</strong>；我相信读者肯定会遇到下面这种异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">03</span>-<span class="number">18</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">56.074</span>  <span class="number">20709</span>-<span class="number">20709</span>/com.weishu.intercept_activity.app E/AndroidRuntime﹕ FATAL EXCEPTION: main</span><br><span class="line">    Process: com.weishu.intercept_activity.app, PID: <span class="number">20709</span></span><br><span class="line">    android.content.ActivityNotFoundException: Unable to find explicit activity <span class="class"><span class="keyword">class</span> </span>&#123;com.weishu.intercept_activity.app/com.weishu.intercept_activity.app.TargetActivity&#125;; have you declared <span class="keyword">this</span> activity in your AndroidManifest.xml?</span><br></pre></td></tr></table></figure><p>『必须在AndroidManifest.xml中显示声明使用的Activity』这个硬性要求很大程度上限制了插件系统的发挥：假设我们需要启动一个插件的Activity，插件使用的Activity是无法预知的，这样肯定也不会在Manifest文件中声明；如果插件新添加一个Activity，主程序的AndroidManifest.xml就需要更新；既然双方都需要修改升级，何必要使用插件呢？这已经违背了动态加载的初衷：不修改插件框架而动态扩展功能。</p><p>能不能想办法绕过这个限制呢？</p><p>束手无策啊，怎么办？借刀杀人偷梁换柱无中生有以逸待劳乘火打劫瞒天过海…等等！偷梁换柱瞒天过海？貌似可以一试。</p><p>我们可以耍个障眼法：既然AndroidManifest文件中必须声明，那么我就声明一个（或者有限个）替身Activity好了，当需要启动插件的某个Activity的时候，先让系统以为启动的是AndroidManifest中声明的那个替身，暂时骗过系统；然后到合适的时候又替换回我们需要启动的真正的Activity；所谓瞒天过海，莫过如此！</p><p>现在有了方案了，但是该如何做呢？兵书又说，知己知彼百战不殆！如果连Activity的启动过程都不熟悉，怎么完成这个瞒天过海的过程？</p><h2 id="Activity启动过程"><a href="#Activity启动过程" class="headerlink" title="Activity启动过程"></a>Activity启动过程</h2><p>启动Activity非常简单，一个<code>startActivity</code>就完事了；那么在这个简单调用的背后发生了什么呢？Look the fucking source code！</p><p>关于Activity 的启动过程，也不是三言两语能解释清楚的，如果按照源码一步一步走下来，插件化系列文章就不用写了；所以这里我就给出一个大致流程，只列出关键的调用点（以Android 6.0源码为例）；如果读者希望更详细的讲解，可以参考老罗的 <a href="http://blog.csdn.net/luoshengyang/article/details/6685853" target="_blank" rel="noopener"> Android应用程序的Activity启动过程简要介绍和学习计划</a></p><p>首先是Activity类的<code>startActivity</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    startActivity(intent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟着这个方法一步一步跟踪，会发现它最后在<code>startActivityForResult</code>里面调用了Instrument对象的<code>execStartActivity</code>方法；接着在这个函数里面调用了ActivityManagerNative类的<code>startActivity</code>方法；这个过程在前文已经反复举例讲解了，我们知道接下来会通过Binder IPC到<code>AMS</code>所在进程调用<code>AMS</code>的<code>startActivity</code>方法；Android系统的组件生命周期管理就是在<code>AMS</code>里面完成的，那么在<code>AMS</code>里面到底做了什么呢？</p><p>ActivityManagerService的<code>startActivity</code>方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final int startActivity(IApplicationThread caller, String callingPackage,</span><br><span class="line">        Intent intent, String resolvedType, IBinder resultTo,</span><br><span class="line">        String resultWho, int requestCode, int startFlags,</span><br><span class="line">        String profileFile, ParcelFileDescriptor profileFd, Bundle options) &#123;</span><br><span class="line">    return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode,</span><br><span class="line">            startFlags, profileFile, profileFd, options, UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，直接调用了<code>startActivityAsUser</code>这个方法；接着是<code>ActivityStackSupervisor</code>类的<code>startActivityMayWait</code>方法。这个ActivityStackSupervisor类到底是个啥？如果仔细查阅，低版本的Android源码上是没有这个类的；后来AMS的代码进行了部分重构，关于Activity栈管理的部分单独提取出来成为了<code>ActivityStackSupervisor</code>类；好了，继续看代码。</p><p>startActivityMayWait这个方法前面对参数进行了一系列处理，我们需要知道的是，在这个方法内部对传进来的Intent进行了解析，并尝试从中取出关于启动Activity的信息。</p><p>然后这个方法调用了startActivityLocked方法；在startActivityLocked方法内部进行了一系列重要的检查：比如权限检查，Activity的exported属性检查等等；我们上文所述的，启动没有在Manifestfest中显示声明的Activity抛异常也是这里发生的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) &#123;</span><br><span class="line">    // We couldn&apos;t find the specific class specified in the Intent.</span><br><span class="line">    // Also the end of the line.</span><br><span class="line">    err = ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回ActivityManager.START_CLASS_NOT_FOUND之后，在Instrument的execStartActivity返回之后会检查这个值，然后跑出异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case ActivityManager.START_CLASS_NOT_FOUND:</span><br><span class="line">    if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null)</span><br><span class="line">        throw new ActivityNotFoundException(</span><br><span class="line">                &quot;Unable to find explicit activity class &quot;</span><br><span class="line">                + ((Intent)intent).getComponent().toShortString()</span><br><span class="line">                + &quot;; have you declared this activity in your AndroidManifest.xml?&quot;);</span><br></pre></td></tr></table></figure><p>源码看到这里，我们已经确认了『必须在AndroidManifest.xml中显示声明使用的Activity』的原因；然而这个校检过程发生在<code>AMS</code>所在的进程<code>system_server</code>，我们没有办法篡改，只能另寻他路。</p><p>OK，我们继续跟踪源码；在startActivityLocked之后处理的都是Activity任务栈相关内容，这一系列ActivityStack和ActivityStackSupervisor纠缠不清的调用看下图就明白了；不明白也没关系: D 目前用处不大。</p><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1458296458099.png" alt="调用流程图"></p><p>这一系列调用最终到达了ActivityStackSupervisor的realStartActivityLocked方法；人如其名，这个方法开始了真正的“启动Activity”：它调用了ApplicationThread的scheduleLaunchActivity方法，开始了真正的Activity对象创建以及启动过程。</p><p>这个ApplicationThread是什么，是一个线程吗？与ActivityThread有什么区别和联系？</p><p>不要被名字迷惑了，这个ApplicationThread实际上是一个Binder对象，是App所在的进程与AMS所在进程system_server通信的桥梁；在Activity启动的过程中，App进程会频繁地与AMS进程进行通信：</p><ol><li>App进程会委托AMS进程完成Activity生命周期的管理以及任务栈的管理；这个通信过程AMS是Server端，App进程通过持有AMS的client代理ActivityManagerNative完成通信过程；</li><li>AMS进程完成生命周期管理以及任务栈管理后，会把控制权交给App进程，让App进程完成Activity类对象的创建，以及生命周期回调；这个通信过程也是通过Binder完成的，App所在server端的Binder对象存在于ActivityThread的内部类ApplicationThread；AMS所在client通过持有IApplicationThread的代理对象完成对于App进程的通信。</li></ol><p>App进程与AMS进程的通信过程如图所示：</p><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1458300329231.png" width="500"></p><p>App进程内部的ApplicationThread server端内部有自己的Binder线程池，它与App主线程的通信通过Handler完成，这个Handler存在于ActivityThread类，它的名字很简单就叫<code>H</code>，这一点我们接下来就会讲到。</p><p>现在我们明白了这个ApplicationThread到底是个什么东西，接上文继续跟踪Activity的启动过程；我们查看ApplicationThread的<code>scheduleLaunchActivity</code>方法，这个方法很简单，就是包装了参数最终使用Handler发了一个消息。</p><p>正如刚刚所说，ApplicationThread所在的Binder服务端使用Handler与主线程进行通信，这里的scheduleLaunchActivity方法直接把启动Activity的任务通过一个消息转发给了主线程；我们查看Handler类对于这个消息的处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">ActivityClientRecord r = (ActivityClientRecord)msg.obj;</span><br><span class="line"></span><br><span class="line">r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">        r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">handleLaunchActivity(r, null);</span><br><span class="line">Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br></pre></td></tr></table></figure><p>可以看到，这里直接调用了ActivityThread的handleLaunchActivity方法，在这个方法内部有一句非常重要：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Activity a = performLaunchActivity(r, customIntent);</span><br></pre></td></tr></table></figure><p>绕了这么多弯，我们的Activity终于被创建出来了！继续跟踪这个performLaunchActivity方法看看发生了什么；由于这个方法较长，我就不贴代码了，读者可以自行查阅；要指出的是，这个方法做了两件很重要的事情：</p><ol><li>使用ClassLoader加载并通过反射创建Activity对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">activity = mInstrumentation.newActivity(</span><br><span class="line">        cl, component.getClassName(), r.intent);</span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure><ol><li>如果Application还没有创建，那么创建Application对象并回调相应的生命周期方法；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity的启动过程到这里就结束了，可能读者还是觉得迷惑：不就是调用了一系列方法吗？具体做了什么还是不太清楚，而且为什么Android要这么设计？</p><p>方法调用链再长也木有关系，有两点需要明白：</p><ol><li>平时我们所说的Application被创建了，onCreate方法被调用了，我们或许并没有意识到我们所说的<code>Application, Activity</code>除了代表Android应用层通常所代表的“组件”之外，它们其实都是普通的Java对象，也是需要被构造函数构造出来的对象的；在这个过程中，我们明白了这些对象到底是如何被创建的。</li><li>为什么需要一直与AMS进行通信？哪些操作是在AMS中进行的？其实<code>AMS</code>正如名字所说，管理所有的“活动”，整个系统的Activity堆栈，Activity生命周期回调都是由AMS所在的系统进程system_server帮开发者完成的；Android的Framework层帮忙完成了诸如生命周期管理等繁琐复杂的过程，简化了应用层的开发。</li></ol><h2 id="瞒天过海——启动不在AndroidManifest-xml中声明的Activity"><a href="#瞒天过海——启动不在AndroidManifest-xml中声明的Activity" class="headerlink" title="瞒天过海——启动不在AndroidManifest.xml中声明的Activity"></a>瞒天过海——启动不在AndroidManifest.xml中声明的Activity</h2><h3 id="简要分析"><a href="#简要分析" class="headerlink" title="简要分析"></a>简要分析</h3><p>通过上文的分析，我们已经对Activity的启动过程了如指掌了；就让我们干点坏事吧 :D</p><p>对与『必须在AndroidManifest.xml中显示声明使用的Activity』这个问题，上文给出了思路——瞒天过海；我们可以在AndroidManifest.xml里面声明一个替身Activity，然后<strong>在合适的时候</strong>把这个假的替换成我们真正需要启动的Activity就OK了。</p><p>那么问题来了，『合适的时候』到底是什么时候？在前文<a href="Hook机制之代理Hook.md">Hook机制之动态代理</a>中我们提到过Hook过程最重要的一步是<strong>寻找Hook点</strong>；如果是在同一个进程，<code>startActivity</code>到Activity真正启动起来这么长的调用链，我们随便找个地方Hook掉就完事儿了；但是问题木有这么简单。</p><p>Activity启动过程中很多重要的操作（正如上文分析的『必须在AndroidManifest.xml中显式声明要启动的Activity』)都不是在App进程里面执行的，而是在AMS所在的系统进程system_server完成，由于<strong>进程隔离</strong>的存在，我们对别的进程无能为力；所以这个Hook点就需要花点心思了。</p><p>这时候Activity启动过程的知识就派上用场了；虽然整个启动过程非常复杂，但其实一张图就能总结：</p><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1458532084072.png" alt="简要启动过程"></p><p>先从App进程调用<code>startActivity</code>；然后通过IPC调用进入系统进程system_server，完成Activity管理以及一些校检工作，最后又回到了APP进程完成真正的Activioty对象创建。</p><p>由于这个检验过程是在AMS进程完成的，我们对system_server进程里面的操作无能为力，只有在我们APP进程里面执行的过程才是有可能被Hook掉的，也就是第一步和第三步；具体应该怎么办呢？</p><p>既然需要一个显式声明的Activity，那就声明一个！<strong>可以在第一步假装启动一个已经在AndroidManifest.xml里面声明过的替身Activity，让这个Activity进入AMS进程接受检验；最后在第三步的时候换成我们真正需要启动的Activity</strong>；这样就成功欺骗了AMS进程，瞒天过海！</p><p>说到这里，是不是有点小激动呢？我们写个demo验证一下：『启动一个并没有在AndroidManifest.xml中显示声明的Activity』</p><h3 id="实战过程"><a href="#实战过程" class="headerlink" title="实战过程"></a>实战过程</h3><p>具体来说，我们打算实现如下功能：在MainActivity中启动一个并没有在AndroidManifest.xml中声明的TargetActivity；按照上文分析，我们需要声明一个替身Activity，我们叫它StubActivity；</p><p>那么，我们的AndroidManifest.xml如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">package</span>=<span class="string">"com.weishu.intercept_activity.app"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">            &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 替身Activity, 用来欺骗AMS  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".StubActivity"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>OK，那么我们启动TargetActivity很简单，就是个<code>startActivity</code>调用的事：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, TargetActivity.class));</span><br></pre></td></tr></table></figure><p>如果你直接这么运行，肯定会直接抛出ActivityNotFoundException然后直接退出；我们接下来要做的就是让这个调用成功启动TargetActivity。</p><h4 id="狸猫换太子——使用替身Activity绕过AMS"><a href="#狸猫换太子——使用替身Activity绕过AMS" class="headerlink" title="狸猫换太子——使用替身Activity绕过AMS"></a>狸猫换太子——使用替身Activity绕过AMS</h4><p>由于<code>AMS</code>进程会对Activity做显式声明验证，因此在<br>启动Activity的控制权转移到<code>AMS</code>进程之前，我们需要想办法<strong>临时</strong>把TargetActivity替换成替身StubActivity；在这之间有很长的一段调用链，我们可以轻松Hook掉；选择什么地方Hook是一个很自由的事情，但是Hook的步骤越后越可靠——Hook得越早，后面的调用就越复杂，越容易出错。</p><p>我们可以选择在进入<code>AMS</code>进程的入口进行Hook，具体来说也就是Hook <code>AMS</code>在本进程的代理对象ActivityManagerNative。如果你不知道如何Hook掉这个AMS的代理对象，请查阅我之前的文章 <a href="Hook机制之AMS&amp;PMS.md">Hook机制之AMS&amp;PMS</a></p><p>我们Hook掉ActivityManagerNative对于startActivity方法的调用，替换掉交给AMS的intent对象，将里面的TargetActivity的暂时替换成已经声明好的替身StubActivity；这种Hook方式 <a href="Hook机制之AMS&amp;PMS.md">前文</a> 讲述的很详细，不赘述；替换的关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">"startActivity"</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="comment">// 只拦截这个方法</span></span><br><span class="line">    <span class="comment">// 替换参数, 任你所为;甚至替换原始Activity启动别的Activity偷梁换柱</span></span><br><span class="line">    <span class="comment">// API 23:</span></span><br><span class="line">    <span class="comment">// public final Activity startActivityNow(Activity parent, String id,</span></span><br><span class="line">    <span class="comment">// Intent intent, ActivityInfo activityInfo, IBinder token, Bundle state,</span></span><br><span class="line">    <span class="comment">// Activity.NonConfigurationInstances lastNonConfigurationInstances) &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到参数里面的第一个Intent 对象</span></span><br><span class="line"></span><br><span class="line">    Intent raw;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> Intent) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    raw = (Intent) args[index];</span><br><span class="line"></span><br><span class="line">    Intent newIntent = <span class="keyword">new</span> Intent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里包名直接写死,如果再插件里,不同的插件有不同的包  传递插件的包名即可</span></span><br><span class="line">    String targetPackage = <span class="string">"com.weishu.intercept_activity.app"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里我们把启动的Activity临时替换为 StubActivity</span></span><br><span class="line">    ComponentName componentName = <span class="keyword">new</span> ComponentName(targetPackage, StubActivity.class.getCanonicalName());</span><br><span class="line">    newIntent.setComponent(componentName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把我们原始要启动的TargetActivity先存起来</span></span><br><span class="line">    newIntent.putExtra(HookHelper.EXTRA_TARGET_INTENT, raw);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换掉Intent, 达到欺骗AMS的目的</span></span><br><span class="line">    args[index] = newIntent;</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, <span class="string">"hook success"</span>);</span><br><span class="line">    <span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> method.invoke(mBase, args);</span><br></pre></td></tr></table></figure><p>通过这个替换过程，在ActivityManagerNative的startActivity调用之后，system_server端收到Binder驱动的消息，开始执行ActivityManagerService里面真正的<code>startActivity</code>方法；这时候AMS看到的<code>intent</code>参数里面的组件已经是<code>StubActivity</code>了，因此可以成功绕过检查，这时候如果不做后面的Hook，直接调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, TargetActivity.class));</span><br></pre></td></tr></table></figure><p>也不会出现上文的ActivityNotFoundException</p><h4 id="借尸还魂——拦截Callback从恢复真身"><a href="#借尸还魂——拦截Callback从恢复真身" class="headerlink" title="借尸还魂——拦截Callback从恢复真身"></a>借尸还魂——拦截Callback从恢复真身</h4><p>行百里者半九十。现在我们的<code>startActivity</code>启动一个没有显式声明的Activity已经不会抛异常了，但是要真正正确地把TargetActivity启动起来，还有一些事情要做。其中最重要的一点是，我们用替身StubActivity临时换了TargetActivity，肯定需要在『合适的』时候替换回来；接下来我们就完成这个过程。</p><p>在AMS进程里面我们是没有办法换回来的，因此我们要等AMS把控制权交给App所在进程，也就是上面那个『Activity启动过程简图』的第三步。AMS进程转移到App进程也是通过Binder调用完成的，承载这个功能的Binder对象是IApplicationThread；在App进程它是Server端，在Server端接受Binder远程调用的是Binder线程池，Binder线程池通过Handler将消息转发给App的主线程；（我这里不厌其烦地叙述Binder调用过程，希望读者不要反感，其一加深印象，其二懂Binder真的很重要）我们可以在这个<strong>Handler里面将替身恢复成真身</strong>。</p><p>这里不打算讲述Handler 的原理，我们简单看一下Handler是如何处理接收到的Message的，如果我们能拦截这个Message的接收过程，就有可能完成替身恢复工作；Handler类的<code>dispathMesage</code>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个方法可以看出来，Handler类消息分发的过程如下：</p><ol><li>如果传递的Message本身就有callback，那么直接使用Message对象的callback方法；</li><li>如果Handler类的成员变量<code>mCallback</code>存在，那么首先执行这个<code>mCallback</code>回调；</li><li>如果<code>mCallback</code>的回调返回<code>true</code>，那么表示消息已经成功处理；直接结束。</li><li>如果<code>mCallback</code>的回调返回<code>false</code>，那么表示消息没有处理完毕，会继续使用Handler类的<code>handleMessage</code>方法处理消息。</li></ol><p>那么，ActivityThread中的Handler类<code>H</code>是如何实现的呢？<code>H</code>的部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</span><br><span class="line">            ActivityClientRecord r = (ActivityClientRecord)msg.obj;</span><br><span class="line"></span><br><span class="line">            r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                    r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">            handleLaunchActivity(r, <span class="keyword">null</span>);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RELAUNCH_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityRestart"</span>);</span><br><span class="line">            ActivityClientRecord r = (ActivityClientRecord)msg.obj;</span><br><span class="line">            handleRelaunchActivity(r);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下略</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>H</code>类仅仅重载了<code>handleMessage</code>方法；通过dispathMessage的消息分发过程得知，我们可以拦截这一过程：<strong>把这个<code>H</code>类的<code>mCallback</code>替换为我们的自定义实现</strong>，这样<code>dispathMessage</code>就会首先使用这个自定义的<code>mCallback</code>，然后看情况使用<code>H</code>重载的<code>handleMessage</code>。</p><p>这个<code>Handler.Callback</code>是一个接口，我们可以使用动态代理或者普通代理完成Hook，这里我们使用普通的静态代理方式；创建一个自定义的Callback类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* package */</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThreadHandlerCallback</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Handler mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActivityThreadHandlerCallback</span><span class="params">(Handler base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="comment">// ActivityThread里面 "LAUNCH_ACTIVITY" 这个字段的值是100</span></span><br><span class="line">            <span class="comment">// 本来使用反射的方式获取最好, 这里为了简便直接使用硬编码</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">                handleLaunchActivity(msg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mBase.handleMessage(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里简单起见,直接取出TargetActivity;</span></span><br><span class="line"></span><br><span class="line">        Object obj = msg.obj;</span><br><span class="line">        <span class="comment">// 根据源码:</span></span><br><span class="line">        <span class="comment">// 这个对象是 ActivityClientRecord 类型</span></span><br><span class="line">        <span class="comment">// 我们修改它的intent字段为我们原来保存的即可.</span></span><br><span class="line"><span class="comment">/*        switch (msg.what) &#123;</span></span><br><span class="line"><span class="comment">/             case LAUNCH_ACTIVITY: &#123;</span></span><br><span class="line"><span class="comment">/                 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart");</span></span><br><span class="line"><span class="comment">/                 final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/                 r.packageInfo = getPackageInfoNoCheck(</span></span><br><span class="line"><span class="comment">/                         r.activityInfo.applicationInfo, r.compatInfo);</span></span><br><span class="line"><span class="comment">/                 handleLaunchActivity(r, null);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 把替身恢复成真身</span></span><br><span class="line">            Field intent = obj.getClass().getDeclaredField(<span class="string">"intent"</span>);</span><br><span class="line">            intent.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Intent raw = (Intent) intent.get(obj);</span><br><span class="line"></span><br><span class="line">            Intent target = raw.getParcelableExtra(HookHelper.EXTRA_TARGET_INTENT);</span><br><span class="line">            raw.setComponent(target.getComponent());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Callback类的使命很简单：<strong>把替身StubActivity恢复成真身TargetActivity</strong>；有了这个自定义的Callback之后我们需要把ActivityThread里面处理消息的Handler类<code>H</code>的的<code>mCallback</code>修改为自定义callback类的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取到当前的ActivityThread对象</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Field currentActivityThreadField = activityThreadClass.getDeclaredField(<span class="string">"sCurrentActivityThread"</span>);</span><br><span class="line">currentActivityThreadField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object currentActivityThread = currentActivityThreadField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于ActivityThread一个进程只有一个,我们获取这个对象的mH</span></span><br><span class="line">Field mHField = activityThreadClass.getDeclaredField(<span class="string">"mH"</span>);</span><br><span class="line">mHField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Handler mH = (Handler) mHField.get(currentActivityThread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置它的回调, 根据源码:</span></span><br><span class="line"><span class="comment">// 我们自己给他设置一个回调,就会替代之前的回调;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        public void dispatchMessage(Message msg) &#123;</span></span><br><span class="line"><span class="comment">//            if (msg.callback != null) &#123;</span></span><br><span class="line"><span class="comment">//                handleCallback(msg);</span></span><br><span class="line"><span class="comment">//            &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                if (mCallback != null) &#123;</span></span><br><span class="line"><span class="comment">//                    if (mCallback.handleMessage(msg)) &#123;</span></span><br><span class="line"><span class="comment">//                        return;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                handleMessage(msg);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">Field mCallBackField = Handler.class.getDeclaredField(<span class="string">"mCallback"</span>);</span><br><span class="line">mCallBackField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">mCallBackField.set(mH, <span class="keyword">new</span> ActivityThreadHandlerCallback(mH));</span><br></pre></td></tr></table></figure><p>到这里，我们已经成功地绕过<code>AMS</code>，完成了『启动没有在AndroidManifest.xml中显式声明的Activity』的过程；瞒天过海，这种玩弄系统与股掌之中的快感你们能体会到吗？</p><h4 id="僵尸or活人？——能正确收到生命周期回调吗"><a href="#僵尸or活人？——能正确收到生命周期回调吗" class="headerlink" title="僵尸or活人？——能正确收到生命周期回调吗"></a>僵尸or活人？——能正确收到生命周期回调吗</h4><p>虽然我们完成了『启动没有在AndroidManifest.xml中显式声明的Activity 』，但是启动的TargetActivity是否有自己的生命周期呢，我们还需要额外的处理过程吗？</p><p>实际上TargetActivity已经是一个有血有肉的Activity了：它具有自己正常的生命周期；可以运行<a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">Demo代码</a>验证一下。</p><p>这个过程是如何完成的呢？我们以<code>onDestroy</code>为例简要分析一下：</p><blockquote><p>从Activity的<code>finish</code>方法开始跟踪，最终会通过ActivityManagerNative到<code>AMS</code>然后接着通过ApplicationThread到ActivityThread，然后通过<code>H</code>转发消息到ActivityThread的handleDestroyActivity，接着这个方法把任务交给performDestroyActivity完成。</p></blockquote><p>在真正分析这个方法之前，需要说明一点的是：不知读者是否感受得到，App进程与<code>AMS</code>交互几乎都是这么一种模式，几个角色 ActivityManagerNative, ApplicationThread, ActivityThread以及Handler类<code>H</code>分工明确，读者可以按照这几个角色的功能分析<code>AMS</code>的任何调用过程，屡试不爽；这也是我的初衷——希望分析插件框架的过程中能帮助深入理解Android Framework。</p><p>好了继续分析performDestroyActivity，关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActivityClientRecord r = mActivities.get(token);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...略</span></span><br><span class="line"></span><br><span class="line">mInstrumentation.callActivityOnDestroy(r.activity);</span><br></pre></td></tr></table></figure><p>这里通过<code>mActivities</code>拿到了一个ActivityClientRecord，然后直接把这个record里面的Activity交给Instrument类完成了onDestroy的调用。</p><p>在我们这个demo的场景下，r.activity是TargetActivity还是StubActivity？按理说，由于我们欺骗了<code>AMS</code>，<code>AMS</code>应该只知道<code>StubActivity</code>的存在，它压根儿就不知道TargetActivity是什么，为什么它能正确完成对TargetActivity生命周期的回调呢？</p><p>一切的秘密在<code>token</code>里面。<code>AMS</code>与<code>ActivityThread</code>之间对于Activity的生命周期的交互，并没有直接使用Activity对象进行交互，而是使用一个token来标识，这个token是binder对象，因此可以方便地跨进程传递。Activity里面有一个成员变量<code>mToken</code>代表的就是它，token可以唯一地标识一个Activity对象，它在Activity的<code>attach</code>方法里面初始化；</p><p>在<code>AMS</code>处理Activity的任务栈的时候，使用这个token标记Activity，因此在我们的demo里面，<code>AMS</code>进程里面的token对应的是StubActivity，也就是<code>AMS</code>还在傻乎乎地操作StubActivity（关于这一点，你可以dump出任务栈的信息，可以观察到dump出的确实是StubActivity）。但是在我们App进程里面，token对应的却是TargetActivity！因此，在ActivityThread执行回调的时候，能正确地回调到TargetActivity相应的方法。</p><p>为什么App进程里面，token对应的是TargetActivity呢？</p><p>回到代码，ActivityClientRecord是在<code>mActivities</code>里面取出来的，确实是根据token取；那么这个token是什么时候添加进去的呢？我们看performLaunchActivity就完成明白了：它通过classloader加载了TargetActivity，然后完成一切操作之后把这个activity添加进了<code>mActivities</code>！另外，在这个方法里面我们还能看到对Ativity<code>attach</code>方法的调用，它传递给了新创建的Activity一个token对象，而这个token是在ActivityClientRecord构造函数里面初始化的。</p><p>至此我们已经可以确认，通过这种方式启动的Activity有它自己完整而独立的生命周期！</p><h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>本文讲述了『启动一个并没有在AndroidManifest.xml中显示声明的Activity』的解决办法，我们成功地绕过了Android的这个限制，这个是插件Activity管理技术的基础；但是要做到启动一个插件Activity问题远没有这么简单。</p><p>首先，在Android中，Activity有不同的启动模式；我们声明了一个替身StubActivity，肯定没有满足所有的要求；因此，我们需要在AndroidManifest.xml中声明一系列的有不同launchMode的Activity，还需要完成替身与真正Activity launchMode的匹配过程；这样才能完成启动各种类型Activity的需求，关于这一点，在 DroidPlugin 的com.morgoo.droidplugin.stub包下面可以找到。</p><p>另外，每启动一个插件的Activity都需要一个StubActivity，但是AndroidManifest.xml中肯定只能声明有限个，如果一直<code>startActivity</code>而不finish的话，那么理论上就需要无限个StubActivity；这个问题该如何解决呢？事实上，这个问题在技术上没有好的解决办法。但是，如果你的App startActivity了十几次，而没有finish任何一个Activity，这样在Activity的回退栈里面有十几个Activity，用户难道按back十几次回到主页吗？有这种需求说明你的产品设计有问题；一个App一级页面，二级页面..到五六级的页面已经影响体验了，所以，每种LauchMode声明十个StubActivity绝对能满足需求了。</p><p>最后，在本文所述例子中，TargetActivity与StubActivity存在于同一个Apk，因此系统的ClassLoader能够成功加载并创建TargetActivity的实例。但是在实际的插件系统中，要启动的目标Activity肯定存在于一个单独的文件中，系统默认的ClassLoader无法加载插件中的Activity类——系统压根儿就不知道要加载的插件在哪，谈何加载？因此还有一个很重要的问题需要处理：</p><p><strong>我们要完成插件系统中类的加载</strong>，这可以通过自定义ClassLoader实现。解决了『启动没有在AndroidManifest.xml中显式声明的，并且存在于外部文件中的Activity』的问题，插件系统对于Activity的管理才算得上是一个完全体。篇幅所限，欲知后事如何，请听下回分解！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Activity生命周期管理&quot;&gt;&lt;a href=&quot;#Activity生命周期管理&quot; class=&quot;headerlink&quot; title=&quot;Activity生命周期管理&quot;&gt;&lt;/a&gt;Activity生命周期管理&lt;/h1&gt;&lt;p&gt;之前的 &lt;a href=&quot;概述.md&quot;&gt;Android插件化原理解析&lt;/a&gt; 系列文章揭开了Hook机制的神秘面纱，现在我们手握倚天屠龙，那么如何通过这种技术完成插件化方案呢？具体来说，插件中的Activity，Service等组件如何在Android系统上运行起来？&lt;/p&gt;
&lt;p&gt;在Java平台要做到动态运行模块、热插拔可以使用&lt;code&gt;ClassLoader&lt;/code&gt;技术进行动态类加载，比如广泛使用的&lt;code&gt;OSGi&lt;/code&gt;技术。在Android上当然也可以使用动态加载技术，但是仅仅把类加载进来就足够了吗？&lt;code&gt;Activity&lt;/code&gt;，&lt;code&gt;Service&lt;/code&gt;等组件是有生命周期的，它们统一由系统服务&lt;code&gt;AMS&lt;/code&gt;管理；使用&lt;code&gt;ClassLoader&lt;/code&gt;可以从插件中创建Activity对象，但是，一个没有生命周期的Activity对象有什么用？所以在Android系统上，仅仅完成动态类加载是不够的；我们需要想办法把我们加载进来的Activity等组件交给系统管理，让&lt;code&gt;AMS&lt;/code&gt;赋予组件生命周期；这样才算是一个有血有肉的完善的插件化方案。&lt;/p&gt;
&lt;p&gt;接下来的系列文章会讲述 DroidPlugin对于Android四大组件的处理方式，我们且看它如何采用Hook技术坑蒙拐骗把系统玩弄于股掌之中，最终赋予Activity，Service等组件生命周期，完成借尸还魂的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android插件化原理解析——概要</title>
    <link href="https://zhanqq2010.github.io/2018/01/11/%E6%A6%82%E8%BF%B0/"/>
    <id>https://zhanqq2010.github.io/2018/01/11/概述/</id>
    <published>2018-01-11T03:53:35.070Z</published>
    <updated>2018-01-11T04:01:28.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>2015年是Android插件化技术突飞猛进的一年，随着业务的发展各大厂商都碰到了Android Native平台的瓶颈：</p><ol><li>从技术上讲，业务逻辑的复杂导致代码量急剧膨胀，各大厂商陆续出到65535方法数的天花板；同时，运营为王的时代对于模块热更新提出了更高的要求。</li><li>在业务层面上，功能模块的解耦以及维护团队的分离也是大势所趋；各个团队维护着同一个App的不同模块，如果每个模块升级新功能都需要对整个app进行升级，那么发布流程不仅复杂而且效率低下；在讲究小步快跑和持续迭代的移动互联网必将遭到淘汰。</li></ol><p>H5和Hybird可以解决这些问题，但是始终比不上native的用户体验；于是，国外的FaceBook推出了<code>react-native</code>；而国内各大厂商几乎都选择纯native的插件化技术。可以说，Android的未来必将是<code>react-native</code>和插件化的天下。</p><a id="more"></a><p><code>react-native</code>资料很多，但是讲述插件化的却凤毛菱角；插件化技术听起来高深莫测，实际上要解决的就是两个问题：</p><ol><li>代码加载</li><li>资源加载</li></ol><h2 id="代码加载"><a href="#代码加载" class="headerlink" title="代码加载"></a>代码加载</h2><p>类的加载可以使用Java的<code>ClassLoader</code>机制，但是对于Android来说，并不是说类加载进来就可以用了，很多组件都是有“生命”的；因此对于这些有血有肉的类，必须给它们注入活力，也就是所谓的<strong>组件生命周期管理</strong>；</p><p>另外，如何管理加载进来的类也是一个问题。假设多个插件依赖了相同的类，是抽取公共依赖进行管理还是插件单独依赖？这就是<strong>ClassLoader的管理问题</strong>；</p><h2 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h2><p>资源加载方案大家使用的原理都差不多，都是用<code>AssetManager</code>的隐藏方法<code>addAssetPath</code>；但是，不同插件的资源如何管理？是公用一套资源还是插件独立资源？共用资源如何避免资源冲突？对于资源加载，有的方案共用一套资源并采用资源分段机制解决冲突（要么修改<code>aapt</code>要么添加编译插件）；有的方案选择独立资源，不同插件管理自己的资源。</p><p>目前国内开源的较成熟的插件方案有<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="noopener">DL</a>和<a href="https://github.com/Qihoo360/DroidPlugin" target="_blank" rel="noopener">DroidPlugin</a>；但是DL方案仅仅对Frameworl的表层做了处理，严重依赖<code>that</code>语法，编写插件代码和主程序代码需单独区分；而DroidPlugin通过Hook增强了Framework层的很多系统服务，开发插件就跟开发独立app差不多；就拿Activity生命周期的管理来说，DL的代理方式就像是牵线木偶，插件只不过是操纵傀儡而已；而DroidPlugin则是借尸还魂，插件是有血有肉的系统管理的真正组件；DroidPlugin Hook了系统几乎所有的Sevice，欺骗了大部分的系统API；掌握这个Hook过程需要掌握很多系统原理，因此学习DroidPlugin对于整个Android FrameWork层大有裨益。</p><p>接下来的一系列文章将以DroidPlugin为例讲解插件框架的原理，揭开插件化的神秘面纱；同时还能帮助深入理解Android Framewrok；主要内容如下：</p><ul><li><a href="Hook机制之代理Hook.md">Hook机制之动态代理</a></li><li><a href="Hook机制之Binder-Hook.md">Hook机制之Binder Hook</a></li><li><a href="Hook机制之AMS&amp;PMS.md">Hook机制之AMS&amp;PMS</a></li><li><a href="Activity生命周期管理.md">Activity生命周期管理</a></li><li><a href="ClassLoader管理.md">插件加载机制</a></li><li><a href="BroadcastReceiver插件化.md">广播的管理方式</a></li><li><a href="Service插件化.md">Service的插件化</a></li><li><a href="ContentProvider插件化.md">ContentProvider的插件化</a></li><li>DroidPlugin插件通信机制</li><li>插件机制之资源管理</li><li>不同插件框架方案对比</li><li>插件化的未来</li></ul><p>另外，对于每一章内容都会有详细的demo，具体见<a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>；喜欢就点个关注吧～</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h1&gt;&lt;p&gt;2015年是Android插件化技术突飞猛进的一年，随着业务的发展各大厂商都碰到了Android Native平台的瓶颈：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从技术上讲，业务逻辑的复杂导致代码量急剧膨胀，各大厂商陆续出到65535方法数的天花板；同时，运营为王的时代对于模块热更新提出了更高的要求。&lt;/li&gt;
&lt;li&gt;在业务层面上，功能模块的解耦以及维护团队的分离也是大势所趋；各个团队维护着同一个App的不同模块，如果每个模块升级新功能都需要对整个app进行升级，那么发布流程不仅复杂而且效率低下；在讲究小步快跑和持续迭代的移动互联网必将遭到淘汰。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;H5和Hybird可以解决这些问题，但是始终比不上native的用户体验；于是，国外的FaceBook推出了&lt;code&gt;react-native&lt;/code&gt;；而国内各大厂商几乎都选择纯native的插件化技术。可以说，Android的未来必将是&lt;code&gt;react-native&lt;/code&gt;和插件化的天下。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://zhanqq2010.github.io/2018/01/10/hello-world/"/>
    <id>https://zhanqq2010.github.io/2018/01/10/hello-world/</id>
    <published>2018-01-10T02:20:33.968Z</published>
    <updated>2018-01-10T02:20:33.968Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
